<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な時計リング（淡色＆増殖）</title>
  <style>
    body { margin:0; overflow:hidden; background:#eeeeee; }
    canvas { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

/* ========= 基本セットアップ ========= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0xeeeeee, 1); // 白寄りの灰色
document.body.appendChild(renderer.domElement);

/* ========= 中央の光球（オーラ付き） ========= */
function createGlowTexture(size = 1024) {
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");
  const r = size/2;

  const g = ctx.createRadialGradient(r, r, r*0.05, r, r, r);
  g.addColorStop(0.0, "rgba(255,255,255,1)");
  g.addColorStop(0.2, "rgba(220,240,255,0.7)");
  g.addColorStop(0.5, "rgba(180,200,255,0.35)");
  g.addColorStop(0.8, "rgba(150,180,255,0.15)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);

  return new THREE.CanvasTexture(cvs);
}

const coreGroup = new THREE.Group();
{
  const coreGeo = new THREE.PlaneGeometry(2.5, 2.5);
  const coreMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent: true,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  coreGroup.add(core);

  const auraGeo = new THREE.PlaneGeometry(4.5, 4.5);
  const auraMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent: true,
    opacity: 0.35,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  coreGroup.add(aura);
}
scene.add(coreGroup);

/* ========= ユーティリティ ========= */
// HSL→RGB（0-255）に変換して [r,g,b]
function hslToRgb(h, s, l) {
  // h: 0-360, s/l: 0-1
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = h/60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let [r1,g1,b1] = [0,0,0];
  if (0<=hp && hp<1) [r1,g1,b1] = [c,x,0];
  else if (1<=hp && hp<2) [r1,g1,b1] = [x,c,0];
  else if (2<=hp && hp<3) [r1,g1,b1] = [0,c,x];
  else if (3<=hp && hp<4) [r1,g1,b1] = [0,x,c];
  else if (4<=hp && hp<5) [r1,g1,b1] = [x,0,c];
  else if (5<=hp && hp<6) [r1,g1,b1] = [c,0,x];
  const m = l - c/2;
  return [
    Math.round((r1 + m)*255),
    Math.round((g1 + m)*255),
    Math.round((b1 + m)*255)
  ];
}

// ふわっと輪郭が消えるリング用テクスチャ（色は [r,g,b] で指定）
function createRingTexture(rgb, size = 1024) {
  const [r, g, b] = rgb;
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");
  const rad = size/2;

  // 内側は透明 → 中間で色が乗る → 外側でまた透明
  const grad = ctx.createRadialGradient(rad, rad, rad*0.58, rad, rad, rad*0.96);
  grad.addColorStop(0.0, "rgba(0,0,0,0)");
  grad.addColorStop(0.35, `rgba(${r},${g},${b},0.45)`); // ふんわり色
  grad.addColorStop(0.65, `rgba(${r},${g},${b},0.18)`);
  grad.addColorStop(1.0, "rgba(0,0,0,0)");

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(rad, rad, rad, 0, Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(cvs);
  tex.needsUpdate = true;
  return tex;
}

/* ========= 時計リング（常時表示の3本） ========= */
function createClockRing(radius, rgb) {
  const tex = createRingTexture(rgb);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  return mesh;
}
// やさしい淡色（赤み・緑み・青み）
const secRing = createClockRing(1.40, [255,180,180]);
const minRing = createClockRing(1.70, [180,255,200]);
const hourRing = createClockRing(2.00, [190,200,255]);
// 前面に出す（背景リングに埋もれないようZを少し正に）
secRing.position.z = 0.02;
minRing.position.z = 0.03;
hourRing.position.z = 0.04;
scene.add(secRing, minRing, hourRing);

/* ========= 背景リング（10秒ごとに増える） ========= */
function createBackgroundRing(radius, rgb) {
  const tex = createRingTexture(rgb);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity: 0.32,                // 背景は時計リングより淡く
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  return mesh;
}

// パステル100色パレット（彩度控えめ・明度高め）
const pastelRGB100 = Array.from({length:100}, (_, i) => {
  const h = (i * 3.6) % 360;   // 0..360
  const s = 0.35;              // 35%（淡く）
  const l = 0.80;              // 80%（明るく）
  return hslToRgb(h, s, l);
});

const extraRings = [];
const startTime = Date.now();

/* ========= アニメーション ========= */
function animate() {
  requestAnimationFrame(animate);
  const now = new Date();
  const elapsed = Date.now() - startTime;

  // 時計回転（秒・分・時）
  const sec = now.getSeconds() + now.getMilliseconds()/1000;
  const min = now.getMinutes() + sec/60;
  const hrs = (now.getHours()%12) + min/60;
  secRing.rotation.z  = -(sec/60) * Math.PI*2;
  minRing.rotation.z  = -(min/60) * Math.PI*2;
  hourRing.rotation.z = -(hrs/12) * Math.PI*2;

  // 10秒ごとに外側へ1本追加（背景リング）
  const shouldCount = Math.floor(elapsed / 10000); // 0,1,2,…
  while (extraRings.length < shouldCount) {
    const idx = extraRings.length % pastelRGB100.length;
    const radius = 2.5 + extraRings.length * 0.40; // 既存の外側にどんどん足す
    const ring = createBackgroundRing(radius, pastelRGB100[idx]);
    ring.position.z = -0.01 - extraRings.length * 0.001; // 背景側に少しずつ
    scene.add(ring);
    extraRings.push(ring);
  }

  renderer.render(scene, camera);
}
animate();

/* ========= リサイズ対応 ========= */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>液体＋霧リング</title>
  <style>
    body { margin:0; background:#000; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/controls/OrbitControls.js";

// シーン
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,0,5);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// === 液体のような球体 ===
const sphereGeometry = new THREE.SphereGeometry(1, 128, 128);
const liquidMaterial = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 0.0 },
    color1: { value: new THREE.Color(0.6,0.8,1.0) }, // 淡いブルー
    color2: { value: new THREE.Color(1.0,0.7,0.9) }, // ピンク
    color3: { value: new THREE.Color(0.8,0.7,1.0) }  // パープル
  },
  vertexShader: `
    uniform float time;
    varying vec3 vNormal;
    // 3D ノイズ関数（簡易）
    float noise(vec3 p){
      return sin(p.x*2.1 + time*0.8) * 
             sin(p.y*1.7 + time*1.1) * 
             sin(p.z*2.3 + time*1.3);
    }
    void main() {
      vNormal = normal;
      vec3 pos = position + normal * 0.2 * noise(normal*2.0 + time*0.5);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 color1;
    uniform vec3 color2;
    uniform vec3 color3;
    varying vec3 vNormal;
    void main(){
      float mixVal = abs(vNormal.z);
      vec3 col = mix(color1, color2, mixVal);
      col = mix(col, color3, vNormal.y*0.5+0.5);
      gl_FragColor = vec4(col, 1.0);
    }
  `,
  side: THREE.DoubleSide
});
const liquidSphere = new THREE.Mesh(sphereGeometry, liquidMaterial);
scene.add(liquidSphere);

// === 霧のようなリング ===
function createRing(radius, color){
  const ringGeo = new THREE.RingGeometry(radius, radius+0.05, 128);
  const ringMat = new THREE.ShaderMaterial({
    uniforms: {
      time: { value: 0.0 },
      color: { value: new THREE.Color(color) }
    },
    transparent: true,
    side: THREE.DoubleSide,
    vertexShader: `
      uniform float time;
      varying vec2 vUv;
      void main(){
        vUv = uv;
        vec3 pos = position;
        pos.z += 0.1*sin(uv.x*10.0 + time*1.5);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
      }
    `,
    fragmentShader: `
      uniform vec3 color;
      varying vec2 vUv;
      void main(){
        float alpha = smoothstep(1.0, 0.7, vUv.x); // 外側ほど淡い
        gl_FragColor = vec4(color, alpha*0.4);
      }
    `
  });
  return new THREE.Mesh(ringGeo, ringMat);
}

const rings = [];
const ringColors = ["#aaccff","#ffccdd","#ddccff"];
for(let i=0;i<3;i++){
  const ring = createRing(1.5+i*0.4, ringColors[i]);
  scene.add(ring);
  rings.push(ring);
}

// === アニメーション ===
function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  liquidMaterial.uniforms.time.value = t;

  rings.forEach((r,i)=>{
    r.material.uniforms.time.value = t + i;
    r.rotation.z = t*0.1*(i+1);
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

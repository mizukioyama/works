<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>幻想的な時計リング</title>
  <style>
    body { margin:0; overflow:hidden; }
    canvas { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

// === 基本セットアップ ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xeeeeee, 1);
document.body.appendChild(renderer.domElement);

// === 光球 ===
function createGlowTexture(size=512) {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = size;
  const ctx = canvas.getContext("2d");
  const r = size/2;
  const grad = ctx.createRadialGradient(r,r,r*0.1, r,r,r);
  grad.addColorStop(0,"rgba(255,255,255,1)");
  grad.addColorStop(0.4,"rgba(220,240,255,0.6)");
  grad.addColorStop(0.7,"rgba(180,200,255,0.2)");
  grad.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(canvas);
}

const core = new THREE.Mesh(
  new THREE.PlaneGeometry(3,3),
  new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent:true,
    blending:THREE.AdditiveBlending,
    side:THREE.DoubleSide
  })
);
scene.add(core);

// === 3色リング ===
function createDynamicRing(radius) {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = 1024;
  const ctx = canvas.getContext("2d");
  const tex = new THREE.CanvasTexture(canvas);

  function draw(hueShift) {
    const r = canvas.width/2;
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // 3色サイクル
    const grad = ctx.createConicGradient(0,r,r);
    grad.addColorStop(0,`hsla(${(hueShift)%360}, 100%, 70%, 0.6)`);
    grad.addColorStop(0.33,`hsla(${(hueShift+120)%360}, 100%, 70%, 0.6)`);
    grad.addColorStop(0.66,`hsla(${(hueShift+240)%360}, 100%, 70%, 0.6)`);
    grad.addColorStop(1,`hsla(${(hueShift)%360}, 100%, 70%, 0.6)`);

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(r,r,r,0,Math.PI*2);
    ctx.fill();

    // ソフトマスク
    const mask = ctx.createRadialGradient(r,r,r*0.5, r,r,r*0.95);
    mask.addColorStop(0,"rgba(0,0,0,0)");
    mask.addColorStop(0.6,"rgba(0,0,0,0.8)");
    mask.addColorStop(1,"rgba(0,0,0,0)");
    ctx.globalCompositeOperation="destination-in";
    ctx.fillStyle=mask;
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.globalCompositeOperation="source-over";

    tex.needsUpdate = true;
  }

  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(radius*2,radius*2),
    new THREE.MeshBasicMaterial({
      map: tex,
      transparent:true,
      blending:THREE.AdditiveBlending,
      side:THREE.DoubleSide,
      opacity:0.7
    })
  );

  return {mesh, draw};
}

const secRing = createDynamicRing(1.6);
const minRing = createDynamicRing(2.0);
const hourRing = createDynamicRing(2.4);
scene.add(secRing.mesh, minRing.mesh, hourRing.mesh);

// === 背景リング（時間で追加） ===
function createBackgroundRing(radius, color) {
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = 512;
  const ctx = canvas.getContext("2d");
  const r = canvas.width/2;
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.arc(r,r,r,0,Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(canvas);
  const mesh = new THREE.Mesh(
    new THREE.PlaneGeometry(radius*2, radius*2),
    new THREE.MeshBasicMaterial({
      map:tex,
      transparent:true,
      opacity:0.0,
      blending:THREE.AdditiveBlending,
      side:THREE.DoubleSide
    })
  );
  mesh.userData={created:Date.now(),fade:3000};
  return mesh;
}

const bgGroup = new THREE.Group();
bgGroup.position.z = -5;
scene.add(bgGroup);

const bgRings = [];
const start = Date.now();
const interval = 5000;

// === アニメーション ===
function animate() {
  requestAnimationFrame(animate);
  const now = Date.now();
  const elapsed = now - start;

  // 時計の動き
  const hueShift = (elapsed/50)%360;
  secRing.draw(hueShift);
  minRing.draw(hueShift*0.5);
  hourRing.draw(hueShift*0.2);

  const t = new Date();
  const s = t.getSeconds()+t.getMilliseconds()/1000;
  const m = t.getMinutes()+s/60;
  const h = (t.getHours()%12)+m/60;
  secRing.mesh.rotation.z = -(s/60)*Math.PI*2;
  minRing.mesh.rotation.z = -(m/60)*Math.PI*2;
  hourRing.mesh.rotation.z = -(h/12)*Math.PI*2;

  // 背景リング追加
  const need = Math.floor(elapsed/interval);
  while(bgRings.length<need){
    const r = 3+bgRings.length*0.7;
    const hue = Math.random()*360;
    const color = `hsla(${hue},70%,80%,0.3)`;
    const ring = createBackgroundRing(r,color);
    bgGroup.add(ring);
    bgRings.push(ring);
  }
  // フェードイン
  bgRings.forEach(r=>{
    const age = now-r.userData.created;
    const t = Math.min(1, age/r.userData.fade);
    r.material.opacity = 0.25*t;
  });

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>

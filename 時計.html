<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な時計リング（背景フェード追加・3秒間隔）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { margin:0; overflow:hidden; background:#eeeeee; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

/* ================= Basic setup ================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0xeeeeee, 1);
document.body.appendChild(renderer.domElement);

/* ================= Helpers ================= */
// HSL->RGB (0..255)
function hslToRgb(h, s, l){
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = h / 60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let [r1,g1,b1] = [0,0,0];
  if (0 <= hp && hp < 1) [r1,g1,b1] = [c,x,0];
  else if (1 <= hp && hp < 2) [r1,g1,b1] = [x,c,0];
  else if (2 <= hp && hp < 3) [r1,g1,b1] = [0,c,x];
  else if (3 <= hp && hp < 4) [r1,g1,b1] = [0,x,c];
  else if (4 <= hp && hp < 5) [r1,g1,b1] = [x,0,c];
  else [r1,g1,b1] = [c,0,x];
  const m = l - c/2;
  return [
    Math.round((r1 + m) * 255),
    Math.round((g1 + m) * 255),
    Math.round((b1 + m) * 255)
  ];
}

/* ================= Core (white glowing ball) ================= */
function createGlowTexture(size=1024){
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext('2d');
  const r = size/2;
  const g = ctx.createRadialGradient(r,r,r*0.02, r,r,r);
  g.addColorStop(0.0, "rgba(255,255,255,1)");
  g.addColorStop(0.22, "rgba(255,245,235,0.9)");
  g.addColorStop(0.45, "rgba(210,230,255,0.5)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(cvs);
}

const coreMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(2.5, 2.5),
  new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    side: THREE.DoubleSide
  })
);
// aura (slightly larger)
const auraMesh = new THREE.Mesh(
  new THREE.PlaneGeometry(4.5, 4.5),
  new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent: true,
    opacity: 0.36,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    side: THREE.DoubleSide
  })
);
// group them (fixed scale — no scaling applied later)
const coreGroup = new THREE.Group();
coreGroup.add(coreMesh);
auraMesh.position.z = -0.01;
coreGroup.add(auraMesh);
scene.add(coreGroup);

/* ================= Create single-color soft ring texture =================
   - Fill entire circle with solid rgba(r,g,b,a)
   - Cut inner circle (destination-out) to make a ring (single color)
   - Add a very subtle outer softening stroke to avoid perfectly crisp edge
================================================== */
function createSolidRingTextureRGB([r,g,b], size=1024, innerRatio=0.72, colorAlpha=0.9){
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext('2d');
  const R = size/2;

  // solid filled circle
  ctx.fillStyle = `rgba(${r},${g},${b},${colorAlpha})`;
  ctx.beginPath();
  ctx.arc(R,R,R,0,Math.PI*2);
  ctx.fill();

  // cut inner hole
  ctx.globalCompositeOperation = 'destination-out';
  ctx.beginPath();
  ctx.arc(R,R,R * innerRatio, 0, Math.PI*2);
  ctx.fill();
  ctx.globalCompositeOperation = 'source-over';

  // soft outer feather (very subtle)
  const outerGrad = ctx.createRadialGradient(R,R,R*0.86, R,R,R);
  outerGrad.addColorStop(0, `rgba(${r},${g},${b},0)`);
  outerGrad.addColorStop(1, `rgba(${r},${g},${b},0.08)`);
  ctx.fillStyle = outerGrad;
  ctx.beginPath();
  ctx.arc(R,R,R,0,Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(cvs);
  tex.needsUpdate = true;
  return tex;
}

/* ================= Clock rings (3 fixed, layered) ================= */
// We'll make them single-color rings (no color animation) and layer by z.
function createClockRingMesh(radius, hue, zpos){
  const rgb = hslToRgb(hue, 0.55, 0.68);
  const tex = createSolidRingTextureRGB(rgb, 1024, 0.72, 0.92);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity: 0.95,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(radius*2, radius*2), mat);
  mesh.position.z = zpos;
  return mesh;
}

// choose 3 hues for clear distinct pastel single-colors
const secRing = createClockRingMesh(1.40, 200, 0.12); // bluish
const minRing = createClockRingMesh(1.70, 320, 0.08); // pinkish
const hourRing = createClockRingMesh(2.00,  40, 0.04); // creamy
scene.add(secRing, minRing, hourRing);

/* ================= Background group (always behind) ================= */
const backgroundGroup = new THREE.Group();
backgroundGroup.position.z = -6; // far behind
scene.add(backgroundGroup);

/* ================= Background ring creation (single-color) ================= */
function createBackgroundRingMesh(radius, hueIndex, fadeMs=1400, targetOpacity=0.45){
  const hue = (hueIndex * 13) % 360; // spread hues
  const rgb = hslToRgb(hue, 0.45, 0.72);
  const tex = createSolidRingTextureRGB(rgb, 1024, 0.72, 0.88);
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity: 0.0,            // start invisible -> fade in
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    side: THREE.DoubleSide
  });
  const mesh = new THREE.Mesh(new THREE.PlaneGeometry(radius*2, radius*2), mat);
  mesh.userData = {
    createdAt: Date.now(),
    fadeMs,
    targetOpacity
  };
  return mesh;
}

/* ================= Management / animation ================= */
const startTime = Date.now();
const addInterval = 3000;   // test: 3 seconds
const spacing = 0.36;
const baseRadius = 2.5;
const extraRings = [];

function animate(){
  requestAnimationFrame(animate);
  const now = Date.now();
  const elapsed = now - startTime;

  // rotate clock rings like a clock
  const d = new Date();
  const s = d.getSeconds() + d.getMilliseconds()/1000;
  const m = d.getMinutes() + s/60;
  const h = (d.getHours() % 12) + m/60;
  secRing.rotation.z  = -(s/60) * Math.PI * 2;
  minRing.rotation.z  = -(m/60) * Math.PI * 2;
  hourRing.rotation.z = -(h/12)  * Math.PI * 2;

  // add background rings every addInterval (3s)
  const shouldCount = Math.floor(elapsed / addInterval);
  while (extraRings.length < shouldCount) {
    const idx = extraRings.length;
    const radius = baseRadius + idx * spacing;
    const mesh = createBackgroundRingMesh(radius, idx, 1600, 0.45);
    // place into background group (z = -6 group), also slightly offset z per ring for stable ordering
    mesh.position.z = -0.001 * idx;
    backgroundGroup.add(mesh);
    extraRings.push(mesh);
  }

  // fade-in background rings
  for (const r of extraRings) {
    const t = Math.min(1, (now - r.userData.createdAt) / r.userData.fadeMs);
    r.material.opacity = r.userData.targetOpacity * t;
  }

  renderer.render(scene, camera);
}
animate();

/* ================= Resize ================= */
addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

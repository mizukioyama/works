<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な液体リング（修正版・グローバルTHREE）</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { margin:0; overflow:hidden; background:#111; }
    canvas { display:block; }
  </style>
  <!-- Three.js 本体 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
  <!-- ポストプロセス -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
</head>
<body>
<script>
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x111111, 1);
document.body.appendChild(renderer.domElement);

// Bloom
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.9, 0.8, 0.1);
bloom.threshold = 0.05;
bloom.strength = 0.9;
bloom.radius = 0.6;
composer.addPass(bloom);

// ライト
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const point = new THREE.PointLight(0xffffff, 0.6);
point.position.set(5,5,10);
scene.add(point);

// 中心グループ
const coreGroup = new THREE.Group();
scene.add(coreGroup);

// グロー（Canvasテクスチャ）
function createGlowTexture(size = 512, innerColor='rgba(255,255,255,1)', auraColor='rgba(200,220,255,0.28)') {
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext('2d');
  const r = size/2;
  const g = ctx.createRadialGradient(r,r,r*0.02,r,r,r);
  g.addColorStop(0.0, innerColor);
  g.addColorStop(0.18,'rgba(255,255,255,0.95)');
  g.addColorStop(0.4,auraColor);
  g.addColorStop(1.0,'rgba(0,0,0,0)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(cvs);
}
const glowPlane = new THREE.Mesh(
  new THREE.PlaneGeometry(6,6),
  new THREE.MeshBasicMaterial({
    map: createGlowTexture(),
    transparent:true,
    blending:THREE.AdditiveBlending,
    depthWrite:false,
    side:THREE.DoubleSide
  })
);
coreGroup.add(glowPlane);

// 液体球
const sphereGeo = new THREE.SphereGeometry(1.2, 96, 96);
const sphereMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  roughness:0.45,
  metalness:0.1,
  transmission:0.7,
  transparent:true,
  opacity:0.95,
  clearcoat:0.5
});
const liquidSphere = new THREE.Mesh(sphereGeo, sphereMat);
coreGroup.add(liquidSphere);

// 頂点データ保存
const posAttr = sphereGeo.attributes.position;
const normalAttr = sphereGeo.attributes.normal;
const vertexCount = posAttr.count;
const origPositions = new Float32Array(posAttr.array.length);
origPositions.set(posAttr.array);
const origNormals = new Float32Array(normalAttr.array.length);
origNormals.set(normalAttr.array);
const phases = new Float32Array(vertexCount);
for (let i=0;i<vertexCount;i++) phases[i] = Math.random()*Math.PI*2;

// リング作成
function createRingTexture(color='rgba(102,217,255,1)', size=512) {
  const cvs=document.createElement('canvas');
  cvs.width=cvs.height=size;
  const ctx=cvs.getContext('2d');
  const r=size/2;
  ctx.fillStyle=color;
  ctx.beginPath(); ctx.arc(r,r,r,0,Math.PI*2); ctx.fill();
  const mask=ctx.createRadialGradient(r,r,r*0.42,r,r,r*0.98);
  mask.addColorStop(0,'rgba(0,0,0,0)');
  mask.addColorStop(0.55,'rgba(0,0,0,0.85)');
  mask.addColorStop(0.85,'rgba(0,0,0,0.35)');
  mask.addColorStop(1,'rgba(0,0,0,0)');
  ctx.globalCompositeOperation='destination-in';
  ctx.fillStyle=mask;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(cvs);
}
function createSoftRing(radius,color,z=0) {
  const tex=createRingTexture(color,512);
  return new THREE.Mesh(
    new THREE.PlaneGeometry(radius*2,radius*2),
    new THREE.MeshBasicMaterial({
      map:tex,transparent:true,opacity:0.85,
      blending:THREE.AdditiveBlending,side:THREE.DoubleSide,depthWrite:false
    })
  );
}
const ringSec=createSoftRing(1.4,'rgba(102,217,255,1)',0.05);
const ringMin=createSoftRing(1.7,'rgba(178,102,255,1)',0.08);
const ringHour=createSoftRing(2.0,'rgba(255,120,160,1)',0.1);
scene.add(ringSec,ringMin,ringHour);

// アニメーション
const clock=new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t=clock.getElapsedTime();
  const positions=sphereGeo.attributes.position;
  for(let i=0;i<vertexCount;i++){
    const idx=i*3;
    const ox=origPositions[idx], oy=origPositions[idx+1], oz=origPositions[idx+2];
    const nx=origNormals[idx], ny=origNormals[idx+1], nz=origNormals[idx+2];
    const p=phases[i];
    const n1=Math.sin(ox*2.0+t*0.9+p);
    const n2=Math.cos(oy*1.7+t*0.6+p*0.7);
    const n3=Math.sin(oz*2.8+t*0.4+p*1.3);
    const noise=(n1*0.6+n2*0.35+n3*0.4)*0.12;
    positions.setXYZ(i, ox+nx*noise, oy+ny*noise, oz+nz*noise);
  }
  positions.needsUpdate=true;
  sphereGeo.computeVertexNormals();

  coreGroup.rotation.z=t*0.02;
  ringSec.rotation.z+=0.009;
  ringMin.rotation.z-=0.004;
  ringHour.rotation.z+=0.002;

  composer.render();
}
animate();

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>幻想的な時計リング</title>
  <style>
    body { margin:0; overflow:hidden; background:#eeeeee; }
    canvas { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

/* === 基本セットアップ === */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0xeeeeee, 1);
document.body.appendChild(renderer.domElement);

/* === 光球テクスチャ === */
function createGlowTexture(size=1024){
  const cvs=document.createElement("canvas");
  cvs.width=cvs.height=size;
  const ctx=cvs.getContext("2d");
  const r=size/2;
  const g=ctx.createRadialGradient(r,r,r*0.05, r,r,r);
  g.addColorStop(0.0,"rgba(255,255,255,1.0)");
  g.addColorStop(0.2,"rgba(220,240,255,0.7)");
  g.addColorStop(0.5,"rgba(180,200,255,0.35)");
  g.addColorStop(0.8,"rgba(150,180,255,0.15)");
  g.addColorStop(1.0,"rgba(0,0,0,0)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(cvs);
}

/* === 光球 === */
function createCore(){
  const group=new THREE.Group();
  const core=new THREE.Mesh(
    new THREE.PlaneGeometry(2.5,2.5),
    new THREE.MeshBasicMaterial({
      map:createGlowTexture(),
      transparent:true,
      blending:THREE.AdditiveBlending,
      side:THREE.DoubleSide,
      depthWrite:false
    })
  );
  group.add(core);
  const aura=new THREE.Mesh(
    new THREE.PlaneGeometry(4.5,4.5),
    new THREE.MeshBasicMaterial({
      map:createGlowTexture(),
      transparent:true,
      opacity:0.4,
      blending:THREE.AdditiveBlending,
      side:THREE.DoubleSide,
      depthWrite:false
    })
  );
  group.add(aura);
  return group;
}
const core=createCore();
scene.add(core);

/* === 単色リング === */
function createSolidRing(radius,color){
  const cvs=document.createElement("canvas");
  cvs.width=cvs.height=512;
  const ctx=cvs.getContext("2d");
  const r=cvs.width/2;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.arc(r,r,r,0,Math.PI*2);
  ctx.fill();

  // マスクでふんわり
  const mask=ctx.createRadialGradient(r,r,r*0.4, r,r,r*0.95);
  mask.addColorStop(0.0,"rgba(0,0,0,0)");
  mask.addColorStop(0.5,"rgba(0,0,0,0.7)");
  mask.addColorStop(1.0,"rgba(0,0,0,0)");
  ctx.globalCompositeOperation="destination-in";
  ctx.fillStyle=mask;
  ctx.fillRect(0,0,cvs.width,cvs.height);

  const tex=new THREE.CanvasTexture(cvs);
  const geo=new THREE.PlaneGeometry(radius*2,radius*2);
  const mat=new THREE.MeshBasicMaterial({
    map:tex, transparent:true, opacity:0,
    blending:THREE.AdditiveBlending, side:THREE.DoubleSide
  });
  const mesh=new THREE.Mesh(geo,mat);
  mesh.userData={createdAt:Date.now(),fadeDur:2000,targetOpacity:0.6};
  return mesh;
}

/* === 動的リング === */
function createDynamicRing(radius){
  const cvs=document.createElement("canvas");
  cvs.width=cvs.height=1024;
  const ctx=cvs.getContext("2d");
  const tex=new THREE.CanvasTexture(cvs);
  function draw(hueShift){
    const r=cvs.width/2;
    ctx.clearRect(0,0,cvs.width,cvs.height);
    const grad=ctx.createConicGradient(0,r,r);
    for(let i=0;i<=1;i+=0.2){
      const hue=(i*360+hueShift)%360;
      grad.addColorStop(i,`hsla(${hue},100%,60%,0.25)`);
    }
    ctx.fillStyle=grad;
    ctx.beginPath();ctx.arc(r,r,r,0,Math.PI*2);ctx.fill();
    const mask=ctx.createRadialGradient(r,r,r*0.4,r,r,r*0.95);
    mask.addColorStop(0,"rgba(0,0,0,0)");
    mask.addColorStop(0.5,"rgba(0,0,0,0.7)");
    mask.addColorStop(1,"rgba(0,0,0,0)");
    ctx.globalCompositeOperation="destination-in";
    ctx.fillStyle=mask;ctx.fillRect(0,0,cvs.width,cvs.height);
    ctx.globalCompositeOperation="source-over";
    tex.needsUpdate=true;
  }
  const geo=new THREE.PlaneGeometry(radius*2,radius*2);
  const mat=new THREE.MeshBasicMaterial({
    map:tex,transparent:true,opacity:0.5,
    blending:THREE.AdditiveBlending,side:THREE.DoubleSide
  });
  const mesh=new THREE.Mesh(geo,mat);
  return {mesh,draw};
}
const secRing=createDynamicRing(1.4);
const minRing=createDynamicRing(1.7);
const hourRing=createDynamicRing(2.0);
scene.add(secRing.mesh,minRing.mesh,hourRing.mesh);

/* === パレット（100色HSLA） === */
const palette=Array.from({length:100},(_,i)=>`hsla(${i*3.6},100%,60%,0.5)`);

/* === リング管理 === */
const extraRings=[];
const start=Date.now();
const interval=3000; // 3秒ごと追加
const spacing=0.3;

/* === アニメーション === */
function animate(){
  requestAnimationFrame(animate);
  const now=Date.now();
  const elapsed=now-start;

  // 時計
  const d=new Date();
  const sec=d.getSeconds()+d.getMilliseconds()/1000;
  const min=d.getMinutes()+sec/60;
  const hr=(d.getHours()%12)+min/60;
  secRing.mesh.rotation.z=-(sec/60)*Math.PI*2;
  minRing.mesh.rotation.z=-(min/60)*Math.PI*2;
  hourRing.mesh.rotation.z=-(hr/12)*Math.PI*2;
  const hueShift=(elapsed/100)%360;
  secRing.draw(hueShift);
  minRing.draw(hueShift*0.5);
  hourRing.draw(hueShift*0.2);

  // リング追加
  const count=Math.floor(elapsed/interval);
  while(extraRings.length<count){
    const idx=extraRings.length%palette.length;
    const radius=2.5+extraRings.length*spacing;
    const ring=createSolidRing(radius,palette[idx]);
    scene.add(ring);
    extraRings.push(ring);
  }

  // フェードイン
  extraRings.forEach(r=>{
    const t=Math.min(1,(now-r.userData.createdAt)/r.userData.fadeDur);
    r.material.opacity=r.userData.targetOpacity*t;
  });

  renderer.render(scene,camera);
}
animate();

/* === リサイズ === */
addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

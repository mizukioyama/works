<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な液体リングと球体</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    body { margin:0; overflow:hidden; background:#f0f0f0; }
    canvas { display:block; }
  </style>
</head>
<body>
<!-- Three.js本体と追加モジュール -->
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.162.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
  // --- 基本設定 ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  camera.position.z = 12;

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // --- ポストプロセス: Bloom効果で幻想的に ---
  const composer = new THREE.EffectComposer(renderer);
  const renderPass = new THREE.RenderPass(scene, camera);
  composer.addPass(renderPass);
  const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.0, 0.9, 0.1);
  bloom.threshold = 0.05;
  bloom.strength = 1.2;
  bloom.radius = 0.8;
  composer.addPass(bloom);

  // --- ライティング ---
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const point = new THREE.PointLight(0xffffff, 0.8);
  point.position.set(5,5,10);
  scene.add(point);

  // --- 中央の球体（液体感） ---
  const sphereGeo = new THREE.SphereGeometry(2.0, 96, 96);
  const sphereMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 0.2,
    roughness: 0.4,
    transmission: 0.7,
    transparent: true,
    opacity: 0.95,
    clearcoat: 0.4,
    clearcoatRoughness: 0.2
  });
  const liquidSphere = new THREE.Mesh(sphereGeo, sphereMat);
  scene.add(liquidSphere);

  // 頂点揺らぎ用データ
  const posAttr = sphereGeo.attributes.position;
  const vertexCount = posAttr.count;
  const origPositions = new Float32Array(posAttr.array.length);
  origPositions.set(posAttr.array);
  const phases = new Float32Array(vertexCount);
  for (let i=0;i<vertexCount;i++) phases[i] = Math.random()*Math.PI*2;

  // --- リング生成関数 ---
  function createRing(radius, color, opacity=0.6) {
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = 512;
    const ctx = cvs.getContext('2d');
    const r = cvs.width/2;

    // 単色リング + 境界を淡く
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(r, r, r, 0, Math.PI*2);
    ctx.fill();

    const mask = ctx.createRadialGradient(r, r, r*0.5, r, r, r);
    mask.addColorStop(0.6, 'rgba(0,0,0,0)');
    mask.addColorStop(1.0, 'rgba(0,0,0,1)');
    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = mask;
    ctx.fillRect(0,0,512,512);

    const tex = new THREE.CanvasTexture(cvs);
    const geo = new THREE.PlaneGeometry(radius*2, radius*2);
    const mat = new THREE.MeshBasicMaterial({
      map: tex, transparent: true, opacity: opacity,
      blending: THREE.AdditiveBlending, depthWrite: false, side: THREE.DoubleSide
    });
    return new THREE.Mesh(geo, mat);
  }

  // --- リングを3色追加 ---
  const ring1 = createRing(3.0, 'rgba(102,217,255,1)', 0.5); // 青系
  const ring2 = createRing(4.0, 'rgba(178,102,255,1)', 0.5); // 紫系
  const ring3 = createRing(5.0, 'rgba(255,120,160,1)', 0.5); // ピンク系
  scene.add(ring1, ring2, ring3);

  // --- 背景の淡いリング（霧の演出） ---
  const bgRing = createRing(8.0, 'rgba(200,200,255,0.3)', 0.3);
  bgRing.position.z = -5;
  scene.add(bgRing);

  // --- アニメーション ---
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();

    // 球体の液体的揺らぎ
    const arr = posAttr.array;
    for (let i=0;i<vertexCount;i++) {
      const idx = i*3;
      const ox = origPositions[idx], oy = origPositions[idx+1], oz = origPositions[idx+2];
      const p = phases[i];
      const n = Math.sin(ox*1.2 + t*0.8 + p) + Math.cos(oy*1.3 + t*0.6 + p*0.5);
      const disp = n * 0.08;
      arr[idx]   = ox + (ox/2) * disp;
      arr[idx+1] = oy + (oy/2) * disp;
      arr[idx+2] = oz + (oz/2) * disp;
    }
    posAttr.needsUpdate = true;
    sphereGeo.computeVertexNormals();

    // リングのゆらゆら回転
    ring1.rotation.z += 0.002;
    ring2.rotation.z -= 0.0015;
    ring3.rotation.z += 0.001;

    // リング全体をふわふわ揺らす
    ring1.rotation.x = 0.05 * Math.sin(t*0.7);
    ring2.rotation.y = 0.04 * Math.cos(t*0.5);
    ring3.rotation.x = 0.03 * Math.sin(t*0.9);

    // 背景リングの淡い脈動
    bgRing.material.opacity = 0.2 + 0.1*Math.sin(t*0.4);

    composer.render();
  }
  animate();

  // --- リサイズ対応 ---
  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    composer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>幻想的な光球</title>
  <style>
    body { margin:0; overflow:hidden; background:black; }
    canvas { display:block; }
  </style>
</head>
<body>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // === 基本セットアップ ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === 光球テクスチャ生成 ===
    function createGlowTexture(size = 1024) {
      const canvas = document.createElement("canvas");
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext("2d");
      const r = size / 2;

      // 外側の虹色ぼかし
      const gradient = ctx.createRadialGradient(r, r, r*0.1, r, r, r*0.95);
      gradient.addColorStop(0.0, "rgba(255,255,255,1.0)");
      gradient.addColorStop(0.2, "rgba(255,255,200,0.8)"); // 黄
      gradient.addColorStop(0.4, "rgba(200,255,255,0.6)"); // 水色
      gradient.addColorStop(0.6, "rgba(200,200,255,0.4)"); // 青
      gradient.addColorStop(0.8, "rgba(255,200,255,0.3)"); // 紫
      gradient.addColorStop(1.0, "rgba(0,0,0,0)");         // フェードアウト

      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);

      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    // === 光球メッシュ ===
    const geo = new THREE.PlaneGeometry(4, 4);
    const mat = new THREE.MeshBasicMaterial({
      map: createGlowTexture(),
      transparent: true,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending
    });
    const glow = new THREE.Mesh(geo, mat);
    scene.add(glow);

    // === アニメーション ===
    function animate() {
      requestAnimationFrame(animate);
      glow.rotation.z += 0.001; // ゆっくり回転
      renderer.render(scene, camera);
    }
    animate();

    // === リサイズ対応 ===
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な時計リング（フェードで増える）</title>
  <style>
    body { margin:0; overflow:hidden; background:#eeeeee; }
    canvas { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

/* ---------- 基本セットアップ ---------- */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0xeeeeee, 1);
document.body.appendChild(renderer.domElement);

/* ---------- ユーティリティ: HSL -> RGB ---------- */
function hslToRgb(h, s, l){
  // h:0-360, s/l:0-1 => returns [r,g,b] 0-255
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = h / 60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let [r1,g1,b1] = [0,0,0];
  if (0 <= hp && hp < 1) [r1,g1,b1] = [c, x, 0];
  else if (1 <= hp && hp < 2) [r1,g1,b1] = [x, c, 0];
  else if (2 <= hp && hp < 3) [r1,g1,b1] = [0, c, x];
  else if (3 <= hp && hp < 4) [r1,g1,b1] = [0, x, c];
  else if (4 <= hp && hp < 5) [r1,g1,b1] = [x, 0, c];
  else [r1,g1,b1] = [c, 0, x];
  const m = l - c/2;
  return [
    Math.round((r1 + m) * 255),
    Math.round((g1 + m) * 255),
    Math.round((b1 + m) * 255)
  ];
}

/* ---------- 中央の光球（オーラ） ---------- */
function createGlowTexture(size = 1024) {
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");
  const r = size/2;
  const g = ctx.createRadialGradient(r, r, r*0.02, r, r, r);
  g.addColorStop(0.0, "rgba(255,255,255,1)");
  g.addColorStop(0.2, "rgba(220,240,255,0.8)");
  g.addColorStop(0.5, "rgba(180,200,255,0.35)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);
  return new THREE.CanvasTexture(cvs);
}

const coreGroup = new THREE.Group();
{
  const coreGeo = new THREE.PlaneGeometry(2.5, 2.5);
  const coreMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(), transparent:true, blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide, depthWrite: false
  });
  const coreMesh = new THREE.Mesh(coreGeo, coreMat);
  coreGroup.add(coreMesh);

  const auraGeo = new THREE.PlaneGeometry(4.5, 4.5);
  const auraMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(), transparent:true, opacity:0.36, blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide, depthWrite: false
  });
  const aura = new THREE.Mesh(auraGeo, auraMat);
  coreGroup.add(aura);
}
scene.add(coreGroup);

/* ---------- ふわっとしたリング用テクスチャ作成 ---------- */
function createRingTextureFromRGB(rgb, size = 1024){
  const [r,g,b] = rgb;
  const cvs = document.createElement("canvas");
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext("2d");
  const R = size/2;

  // radial gradient: 内側ほぼ透明 -> 中間で色 -> 外側フェード
  const grad = ctx.createRadialGradient(R, R, R*0.55, R, R, R*0.96);
  grad.addColorStop(0.0, "rgba(0,0,0,0)");
  grad.addColorStop(0.30, `rgba(${r},${g},${b},0.55)`);
  grad.addColorStop(0.60, `rgba(${r},${g},${b},0.28)`);
  grad.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(R, R, R, 0, Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(cvs);
  tex.needsUpdate = true;
  return tex;
}

/* ---------- 時計リング（必ず表示される3本） ---------- */
function createClockRing(radius, rgb, zpos = 0.02) {
  const tex = createRingTextureFromRGB(rgb, 1024);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex, transparent:true, opacity:0.95,
    blending: THREE.NormalBlending, side: THREE.DoubleSide, depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = zpos; // 前面にわずかに出す
  mesh.renderOrder = 3;
  return mesh;
}

// 時計リングの色（淡いが視認性を確保）
const secRing = createClockRing(1.40, [255,180,180], 0.03);
const minRing = createClockRing(1.70, [180,255,200], 0.04);
const hourRing = createClockRing(2.00, [190,200,255], 0.05);
scene.add(secRing, minRing, hourRing);

/* ---------- 背景リング（増えていく。フェードイン付き） ---------- */
function createBackgroundRingMesh(radius, rgb, initialOpacity = 0.35, zOffset = -0.01){
  const tex = createRingTextureFromRGB(rgb, 1024);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex, transparent: true, opacity: 0.0,
    blending: THREE.NormalBlending, side: THREE.DoubleSide, depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = zOffset;
  mesh.userData.targetOpacity = initialOpacity;
  mesh.userData.createdAt = Date.now();
  mesh.userData.fadeDuration = 2000; // ms
  return mesh;
}

/* ---------- パステル系100色パレット（淡く見えるが十分に視認できる） ---------- */
const pastel100 = Array.from({length:100}, (_,i)=>{
  const h = (i * 3.6) % 360;
  const s = 0.55; // ややしっかり目の彩度で淡色でも見える
  const l = 0.70;
  return hslToRgb(h, s, l);
});

/* ---------- 管理変数 ---------- */
const extraRings = []; // {mesh}
const startTime = Date.now();
const intervalMs = 10000; // テスト: 10秒ごとに1本追加
const ringSpacing = 0.40; // 外側へ増える間隔

/* ---------- アニメーションループ ---------- */
function animate(){
  requestAnimationFrame(animate);
  const now = Date.now();
  const elapsed = now - startTime;

  // 回転（秒・分・時）
  const dt = new Date();
  const sec = dt.getSeconds() + dt.getMilliseconds()/1000;
  const min = dt.getMinutes() + sec/60;
  const hrs = (dt.getHours()%12) + min/60;
  secRing.rotation.z  = -(sec/60) * Math.PI*2;
  minRing.rotation.z  = -(min/60) * Math.PI*2;
  hourRing.rotation.z = -(hrs/12)  * Math.PI*2;

  // 追加リング数（背景のみ）
  const shouldCount = Math.floor(elapsed / intervalMs);
  while (extraRings.length < shouldCount) {
    const idx = extraRings.length % pastel100.length;
    const radius = 2.5 + extraRings.length * ringSpacing;
    const colorRGB = pastel100[idx];
    const mesh = createBackgroundRingMesh(radius, colorRGB, 0.34, -0.01 - extraRings.length*0.001);
    // 初期 opacity = 0 (mesh.material.opacity) -> will fade in
    scene.add(mesh);
    extraRings.push(mesh);
  }

  // フェードイン処理（背景リング）
  extraRings.forEach(m => {
    const t = Math.min(1, (now - (m.userData.createdAt || now)) / m.userData.fadeDuration);
    m.material.opacity = (m.userData.targetOpacity || 0.34) * t;
  });

  renderer.render(scene, camera);
}
animate();

/* ---------- ウィンドウリサイズ ---------- */
addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

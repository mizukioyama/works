<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>幻想的な時計リング（単色・層構造・フェード追加）</title>
  <style>
    body { margin:0; overflow:hidden; background:#eeeeee; }
    canvas { display:block; }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<script type="module">
import * as THREE from "three";

/* ========== 基本 ========== */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 20000);
camera.position.z = 10;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0xeeeeee, 1);
document.body.appendChild(renderer.domElement);

/* ========== ユーティリティ: HSL -> RGB(int) ========== */
function hslToRgb(h, s, l){
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = h / 60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let [r1,g1,b1] = [0,0,0];
  if (0 <= hp && hp < 1) [r1,g1,b1] = [c,x,0];
  else if (1 <= hp && hp < 2) [r1,g1,b1] = [x,c,0];
  else if (2 <= hp && hp < 3) [r1,g1,b1] = [0,c,x];
  else if (3 <= hp && hp < 4) [r1,g1,b1] = [0,x,c];
  else if (4 <= hp && hp < 5) [r1,g1,b1] = [x,0,c];
  else [r1,g1,b1] = [c,0,x];
  const m = l - c/2;
  return [
    Math.round((r1 + m) * 255),
    Math.round((g1 + m) * 255),
    Math.round((b1 + m) * 255)
  ];
}

/* ========== コア（光球＋オーラ） ========== */
function createGlowTexture(size = 1024){
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext('2d');
  const r = size/2;
  const g = ctx.createRadialGradient(r,r,r*0.02, r,r,r);
  g.addColorStop(0.0, "rgba(255,255,255,1)");
  g.addColorStop(0.22, "rgba(255,245,235,0.9)");
  g.addColorStop(0.45, "rgba(210,230,255,0.45)");
  g.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(cvs);
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  return tex;
}

const coreGroup = new THREE.Group();
{
  const coreGeo = new THREE.PlaneGeometry(2.5,2.5);
  const coreMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(), transparent:true, blending:THREE.AdditiveBlending,
    side:THREE.DoubleSide, depthWrite:false
  });
  coreGroup.add(new THREE.Mesh(coreGeo, coreMat));

  const auraGeo = new THREE.PlaneGeometry(4.5,4.5);
  const auraMat = new THREE.MeshBasicMaterial({
    map: createGlowTexture(), transparent:true, opacity:0.32, blending:THREE.AdditiveBlending,
    side:THREE.DoubleSide, depthWrite:false
  });
  coreGroup.add(new THREE.Mesh(auraGeo, auraMat));
}
scene.add(coreGroup);

/* ========== ふわっと単色リング用テクスチャ（RGB配列） ========== */
function createSoftRingTextureRGB(rgb, size=1024, inner=0.55, outer=0.98, a1=0.16, a2=0.06){
  const [r,g,b] = rgb;
  const cvs = document.createElement('canvas');
  cvs.width = cvs.height = size;
  const ctx = cvs.getContext('2d');
  const R = size/2;

  // 内側透明→中間で淡い色→外側でさらに淡く→外縁透明
  const grad = ctx.createRadialGradient(R,R,R*inner, R,R,R*outer);
  grad.addColorStop(0.0, "rgba(0,0,0,0)");
  grad.addColorStop(0.35, `rgba(${r},${g},${b},${a1})`);
  grad.addColorStop(0.70, `rgba(${r},${g},${b},${a2})`);
  grad.addColorStop(1.0, "rgba(0,0,0,0)");
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(R,R,R,0,Math.PI*2);
  ctx.fill();

  const tex = new THREE.CanvasTexture(cvs);
  tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
  tex.needsUpdate = true;
  return tex;
}

/* ========== 単色リング Mesh（時計用） ========== */
function createSingleColorRing(radius, rgb, zpos, opacity=0.55){
  const tex = createSoftRingTextureRGB(rgb, 1024, 0.55, 0.98, 0.20, 0.08);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex, transparent:true, opacity,
    blending: THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.z = zpos;
  return mesh;
}

/* ========== 秒・分・時リング（レイヤー分け・単色） ========== */
/* 淡いピンク／ミント／スカイ */
const secRing = createSingleColorRing(1.4, [255,170,190], 0.05, 0.60);
const minRing = createSingleColorRing(1.7, [170,255,210], 0.07, 0.60);
const hourRing = createSingleColorRing(2.0, [170,190,255], 0.09, 0.60);
scene.add(secRing, minRing, hourRing);

/* ========== 背景グループ（常に奥） ========== */
const backgroundGroup = new THREE.Group();
backgroundGroup.position.z = -6;
scene.add(backgroundGroup);

/* ========== 背景リング（追加＆フェード） ========== */
function createBackgroundRingMesh(radius, rgb, targetOpacity=0.22, fadeDur=2000){
  const tex = createSoftRingTextureRGB(rgb, 1024, 0.48, 0.99, 0.14, 0.06);
  const geo = new THREE.PlaneGeometry(radius*2, radius*2);
  const mat = new THREE.MeshBasicMaterial({
    map: tex, transparent:true, opacity:0.0,
    blending: THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.userData = { targetOpacity, createdAt: Date.now(), fadeDuration: fadeDur };
  return mesh;
}

/* ========== パステル100色（全て異なる色） ========== */
const pastel100 = Array.from({length:100}, (_,i)=>{
  const h = (i * 3.6) % 360;     // 0..359
  const s = 0.45;                // ほどよい彩度
  const l = 0.72;                // 明るめ
  return hslToRgb(h, s, l);      // [r,g,b]
});

/* ========== 追加リング管理 ========== */
const extraRings = [];
const startTime = Date.now();
const intervalMs = 10000;   // テスト：10秒ごとに1本追加
const ringSpacing = 0.38;   // 外側への間隔
const baseRadius = 2.5;     // 時計リング(最大2.0)の外側から開始

/* ========== アニメーション ========== */
function animate(){
  requestAnimationFrame(animate);

  // 時計の回転
  const dt = new Date();
  const sec = dt.getSeconds() + dt.getMilliseconds()/1000;
  const min = dt.getMinutes() + sec/60;
  const hrs = (dt.getHours()%12) + min/60;

  secRing.rotation.z  = -(sec/60) * Math.PI*2;
  minRing.rotation.z  = -(min/60) * Math.PI*2;
  hourRing.rotation.z = -(hrs/12) * Math.PI*2;

  // 背景リングの追加（10秒ごと）
  const now = Date.now();
  const shouldCount = Math.floor((now - startTime) / intervalMs);
  while (extraRings.length < shouldCount) {
    const idx = extraRings.length % pastel100.length;
    const rgb = pastel100[idx];
    const radius = baseRadius + extraRings.length * ringSpacing;
    const mesh = createBackgroundRingMesh(radius, rgb, 0.22, 2000);
    backgroundGroup.add(mesh);
    extraRings.push(mesh);
  }

  // フェードイン
  extraRings.forEach(m => {
    const t = Math.min(1, (now - m.userData.createdAt) / m.userData.fadeDuration);
    m.material.opacity = m.userData.targetOpacity * t;
  });

  renderer.render(scene, camera);
}
animate();

/* ========== リサイズ対応 ========== */
addEventListener('resize', ()=>{
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

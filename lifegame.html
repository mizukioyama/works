<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>ランダム光点・鉄板ライフゲーム</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const width = window.innerWidth;
const height = window.innerHeight;
const cols = 60;
const rows = 40;

// --- ライフゲーム配列 ---
let grid = createGrid();
let next = createGrid();

function createGrid() {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => Math.random() > 0.8 ? 1 : 0)
  );
}

// --- Three.js セットアップ ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
camera.position.set(0, 40, 70);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
document.body.appendChild(renderer.domElement);

// 照明（メタリック感＋光沢）
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(20, 30, 10);
scene.add(dirLight);

// 点セル生成
const cellGroup = new THREE.Group();
scene.add(cellGroup);
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const size = Math.random() * 0.6 + 0.4; // ランダムな直径（0.4〜1.0）
    const geo = new THREE.SphereGeometry(size, 16, 16);
    const mat = new THREE.MeshStandardMaterial({
      color: 0xaaaaaa,
      metalness: 1.0,
      roughness: 0.2,
      emissive: 0x555555,      // 自発光で光らせる
      emissiveIntensity: 0.0   // 初期は暗い
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(
      c - cols / 2 + 0.5,
      0,
      r - rows / 2 + 0.5
    );
    mesh.visible = grid[r][c] === 1;
    cellGroup.add(mesh);
  }
}
const cells = cellGroup.children;

// --- ライフゲーム更新 ---
function updateLife() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const n = countNeighbors(grid, r, c);
      if (grid[r][c] === 1 && (n < 2 || n > 3)) next[r][c] = 0;
      else if (grid[r][c] === 0 && n === 3) next[r][c] = 1;
      else next[r][c] = grid[r][c];
    }
  }
  [grid, next] = [next, grid];

  // 表示更新＋発光アニメ
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const idx = r * cols + c;
      const mesh = cells[idx];
      const alive = grid[r][c] === 1;
      mesh.visible = alive;
      if (alive) {
        mesh.material.emissiveIntensity = 0.7 + Math.random() * 0.3;
      }
    }
  }
}

function countNeighbors(arr, x, y) {
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const r = x + i;
      const c = y + j;
      if (r >= 0 && r < rows && c >= 0 && c < cols) {
        sum += arr[r][c];
      }
    }
  }
  return sum;
}

// --- クリック / タッチでセル反転 ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

function toggleCell(intersect) {
  const mesh = intersect.object;
  // セル配列から位置を特定
  const c = Math.round(mesh.position.x + cols / 2 - 0.5);
  const r = Math.round(mesh.position.z + rows / 2 - 0.5);
  if (r >= 0 && r < rows && c >= 0 && c < cols) {
    grid[r][c] = grid[r][c] ? 0 : 1;
    mesh.visible = grid[r][c] === 1;
  }
}

function onClick(event) {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  mouse.set(x, y);
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cells);
  if (intersects.length > 0) toggleCell(intersects[0]);
}
renderer.domElement.addEventListener('click', onClick);
renderer.domElement.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    const touch = e.touches[0];
    onClick({ clientX: touch.clientX, clientY: touch.clientY });
  }
});

// --- アニメーション ---
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// --- 自動更新（ランダム間隔） ---
function randomUpdate() {
  updateLife();
  const delay = Math.random() * 900 + 100; // 0.1〜1秒
  setTimeout(randomUpdate, delay);
}
randomUpdate();

// リサイズ対応
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

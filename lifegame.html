<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>リアル鉄板ライフゲーム</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const width = window.innerWidth;
const height = window.innerHeight;
const cols = 60;
const rows = 40;
let grid = createGrid();
let next = createGrid();

function createGrid() {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => Math.random() > 0.8 ? 1 : 0)
  );
}

// --- Three.js 初期化 ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
camera.position.set(0, 40, 70);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
document.body.appendChild(renderer.domElement);

// 環境光＋方向光
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// 「鉄板」マテリアル (粗いメタリック)
const plateMaterial = new THREE.MeshStandardMaterial({
  color: 0x999999,
  metalness: 0.9,
  roughness: 0.4
});

// セル表示用 Mesh の生成
const cellGroup = new THREE.Group();
scene.add(cellGroup);
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const geo = new THREE.BoxGeometry(1, 0.2, 1);
    const mesh = new THREE.Mesh(geo, plateMaterial.clone());
    mesh.position.set(
      c - cols / 2,
      0,
      r - rows / 2
    );
    mesh.visible = grid[r][c] === 1;
    cellGroup.add(mesh);
  }
}
const cells = cellGroup.children;

// ライフゲーム更新
function updateLife() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const neighbors = countNeighbors(grid, r, c);
      if (grid[r][c] === 1 && (neighbors < 2 || neighbors > 3)) next[r][c] = 0;
      else if (grid[r][c] === 0 && neighbors === 3) next[r][c] = 1;
      else next[r][c] = grid[r][c];
    }
  }
  [grid, next] = [next, grid];
  // 表示更新
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      cells[r * cols + c].visible = grid[r][c] === 1;
    }
  }
}

function countNeighbors(arr, x, y) {
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const r = x + i;
      const c = y + j;
      if (r >= 0 && r < rows && c >= 0 && c < cols) {
        sum += arr[r][c];
      }
    }
  }
  return sum;
}

// --- アニメーション ---
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// --- 自動更新（ランダム速度） ---
function randomUpdate() {
  updateLife();
  // 次回までの待ち時間をランダム 100ms〜1000ms
  const delay = Math.random() * 900 + 100;
  setTimeout(randomUpdate, delay);
}
randomUpdate();

// リサイズ対応
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

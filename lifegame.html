<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>細かい光点ライフゲーム</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; touch-action:none; } /* タッチスクロール防止 */
</style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

const width  = window.innerWidth;
const height = window.innerHeight;

// --- より細かいグリッド ---
const cols = 100;
const rows = 70;

// ライフゲーム配列
let grid = createGrid();
let next = createGrid();

function createGrid() {
  return Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => Math.random() > 0.85 ? 1 : 0)
  );
}

// Three.js セットアップ
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, width/height, 0.1, 1000);
camera.position.set(0, 80, 120);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(width, height);
document.body.appendChild(renderer.domElement);

// 白系ライト
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(40, 80, 40);
scene.add(dirLight);

// セル生成
const cellGroup = new THREE.Group();
scene.add(cellGroup);

for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const size = Math.random() * 0.25 + 0.15; // 0.15〜0.4 で細かく
    const geo  = new THREE.SphereGeometry(size, 16, 16);
    const mat  = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 1.0,
      roughness: 0.1,
      emissive: 0xffffff,          // 白系光
      emissiveIntensity: 0.0
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(c - cols/2 + 0.5, 0, r - rows/2 + 0.5);
    mesh.visible = grid[r][c] === 1;
    cellGroup.add(mesh);
  }
}
const cells = cellGroup.children;

// ライフゲーム更新
function updateLife() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const n = countNeighbors(grid, r, c);
      if (grid[r][c] === 1 && (n < 2 || n > 3)) next[r][c] = 0;
      else if (grid[r][c] === 0 && n === 3)    next[r][c] = 1;
      else next[r][c] = grid[r][c];
    }
  }
  [grid, next] = [next, grid];

  // 表示＆発光
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const idx = r * cols + c;
      const mesh = cells[idx];
      const alive = grid[r][c] === 1;
      mesh.visible = alive;
      if (alive) {
        mesh.material.emissiveIntensity = 0.6 + Math.random() * 0.4;
      }
    }
  }
}

function countNeighbors(arr, x, y) {
  let sum = 0;
  for (let i = -1; i <= 1; i++) {
    for (let j = -1; j <= 1; j++) {
      if (i === 0 && j === 0) continue;
      const r = x + i;
      const c = y + j;
      if (r >= 0 && r < rows && c >= 0 && c < cols) sum += arr[r][c];
    }
  }
  return sum;
}

// クリック／タッチ対応（確実に反応）
const raycaster = new THREE.Raycaster();
const pointer   = new THREE.Vector2();

function toggleCell(clientX, clientY) {
  const rect = renderer.domElement.getBoundingClientRect();
  pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(cells);
  if (intersects.length > 0) {
    const mesh = intersects[0].object;
    const c = Math.round(mesh.position.x + cols/2 - 0.5);
    const r = Math.round(mesh.position.z + rows/2 - 0.5);
    if (r >= 0 && r < rows && c >= 0 && c < cols) {
      grid[r][c] = grid[r][c] ? 0 : 1;
      mesh.visible = grid[r][c] === 1;
    }
  }
}

renderer.domElement.addEventListener('click', e => toggleCell(e.clientX, e.clientY));
renderer.domElement.addEventListener('touchstart', e => {
  if (e.touches.length === 1) {
    toggleCell(e.touches[0].clientX, e.touches[0].clientY);
  }
}, {passive:true});

// アニメーション
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// 自動更新（ランダム間隔）
function randomUpdate() {
  updateLife();
  setTimeout(randomUpdate, Math.random() * 800 + 150); // 0.15〜0.95秒
}
randomUpdate();

// リサイズ
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>リアル金属板 – three.js（反射＆カメラ反応）</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body { background: #0b0d12; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Meiryo, sans-serif; }
    #app { position: fixed; inset: 0; }
    .ui {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: #e6edf3;
      opacity: .9;
      font-size: 12px;
      line-height: 1.5;
      user-select: none;
    }
    .ui b { color: #9cd2ff; }
    .ui .pill {
      display:inline-block;
      padding:.2em .6em;
      border:1px solid #2b3139;
      border-radius:999px;
      margin-right:.25em;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="ui">
    <div class="pill">ドラッグ：回転</div>
    <div class="pill">ホイール：ズーム</div>
    <div class="pill">Shift+ドラッグ：パン</div>
    <div style="margin-top:.4em">カメラを動かすほど<b>反射</b>が変化します（動的反射）。</div>
  </div>

  <!-- three.js + 公式アドオンCDNから読み込み -->
  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";
    import { RoomEnvironment } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/environments/RoomEnvironment.js";
    import { FlakesTexture } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/textures/FlakesTexture.js";
    import { RoundedBoxGeometry } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/geometries/RoundedBoxGeometry.js";

    // ---------- 基本セットアップ ----------
    const container = document.getElementById('app');
    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;
    container.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(2.2, 1.6, 3.4);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0.5, 0);

    // ---------- 環境設定 ----------
    const pmrem = new THREE.PMREMGenerator(renderer);
    const env = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
    scene.environment = env;
    scene.background = new THREE.Color(0x0b0d12);

    // ---------- 金属板 ----------
    const flakes = new FlakesTexture();
    const normalMap = new THREE.CanvasTexture(flakes);
    normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;
    normalMap.repeat.set(4, 4);
    normalMap.anisotropy = renderer.capabilities.getMaxAnisotropy();

    const plateGeo = new RoundedBoxGeometry(1.6, 0.02, 1.0, 8, 0.05);
    const plateMat = new THREE.MeshPhysicalMaterial({
      metalness: 1.0,
      roughness: 0.2,
      envMapIntensity: 1.0,
      reflectivity: 1.0,
      clearcoat: 0.6,
      clearcoatRoughness: 0.15,
      normalMap,
      normalScale: new THREE.Vector2(0.3, 0.3),
    });

    const plate = new THREE.Mesh(plateGeo, plateMat);
    plate.position.set(0, 0.6, 0);
    scene.add(plate);

    // ---------- キューブカメラで動的反射 ----------
    const cubeTarget = new THREE.WebGLCubeRenderTarget(512, {
      type: THREE.HalfFloatType,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter,
    });
    cubeTarget.texture.colorSpace = THREE.SRGBColorSpace;
    const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeTarget);
    cubeCamera.position.copy(plate.position);
    scene.add(cubeCamera);

    function updateReflection() {
      plate.visible = false;
      cubeCamera.update(renderer, scene);
      plate.visible = true;
      plateMat.envMap = cubeTarget.texture;
    }

    // ---------- アニメーションループ ----------
    function animate() {
      requestAnimationFrame(animate);
      updateReflection();
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- リサイズ対応 ----------
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>

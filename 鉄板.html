<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>映画クオリティ：リアル鉄板</title>
  <style>
    html,body { height:100%; margin:0; background:#050507; overflow:hidden; }
    #canvas-container { width:100%; height:100%; }
    .ui {
      position:fixed; left:12px; top:12px;
      color:#eee; font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", Meiryo;
      background: rgba(0,0,0,0.25); padding:8px 12px; border-radius:8px;
      font-size:13px;
    }
  </style>
</head>
<body>
  <div class="ui">ドラッグ：回転 / ホイール：ズーム</div>
  <div id="canvas-container"></div>

  <!-- three.js r138 安定版 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/build/three.min.js"></script>

  <!-- OrbitControls -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/controls/OrbitControls.js"></script>

  <!-- Postprocessing 必要な全スクリプト -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.138.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

  <script>
  window.addEventListener('load', function () {
    const container = document.getElementById('canvas-container');

    // シーン・カメラ・レンダラー
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.2, 2.8);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    renderer.physicallyCorrectLights = true;
    container.appendChild(renderer.domElement);

    // ライティング
    const key = new THREE.DirectionalLight(0xffffff, 1.6);
    key.position.set(4, 6, 3);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.6);
    fill.position.set(-3, 2, 1);
    scene.add(fill);

    const rim = new THREE.DirectionalLight(0xffffff, 0.45);
    rim.position.set(0, 3, -5);
    scene.add(rim);

    const ambient = new THREE.AmbientLight(0xffffff, 0.18);
    scene.add(ambient);

    // 環境反射
    const cubeLoader = new THREE.CubeTextureLoader();
    const envMap = cubeLoader.load([
      "https://threejs.org/examples/textures/cube/Bridge2/posx.jpg",
      "https://threejs.org/examples/textures/cube/Bridge2/negx.jpg",
      "https://threejs.org/examples/textures/cube/Bridge2/posy.jpg",
      "https://threejs.org/examples/textures/cube/Bridge2/negy.jpg",
      "https://threejs.org/examples/textures/cube/Bridge2/posz.jpg",
      "https://threejs.org/examples/textures/cube/Bridge2/negz.jpg"
    ]);
    scene.background = new THREE.Color(0x07070a);

    // PBRテクスチャ
    const texLoader = new THREE.TextureLoader();
    const texBase = texLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_plate_001_basecolor.jpg");
    const texNormal = texLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_plate_001_normal.jpg");
    const texRough = texLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_plate_001_roughness.jpg");
    const texMetal = texLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_plate_001_metallic.jpg");
    const texAO = texLoader.load("https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/metal/Metal_plate_001_ambientOcclusion.jpg");

    [texBase, texNormal, texRough, texMetal, texAO].forEach(t => {
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.repeat.set(2.5, 2.5);
    });

    const normalScale = new THREE.Vector2(1.0, 1.0);

    const metalMaterial = new THREE.MeshStandardMaterial({
      map: texBase,
      normalMap: texNormal,
      normalScale: normalScale,
      roughnessMap: texRough,
      metalnessMap: texMetal,
      aoMap: texAO,
      metalness: 1.0,
      roughness: 0.25,
      envMap: envMap,
      envMapIntensity: 1.6,
    });

    const plateGeo = new THREE.BoxGeometry(2.6, 0.06, 1.6, 256, 1, 256);
    plateGeo.attributes.uv2 = plateGeo.attributes.uv;

    const plate = new THREE.Mesh(plateGeo, metalMaterial);
    plate.position.y = 0.15;
    plate.castShadow = true;
    plate.receiveShadow = true;
    scene.add(plate);

    const smallGeo = new THREE.SphereGeometry(0.08, 32, 32);
    const smallMat = new THREE.MeshStandardMaterial({ color:0x7da7ff, metalness:0.6, roughness:0.25, envMap:envMap });
    const s1 = new THREE.Mesh(smallGeo, smallMat); s1.position.set(-0.9, 0.2, 0.2); scene.add(s1);
    const s2 = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12), new THREE.MeshStandardMaterial({color:0xff9f9f, metalness:0.2, roughness:0.45, envMap:envMap})); s2.position.set(0.9,0.17,-0.15); scene.add(s2);

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(10,10), new THREE.MeshStandardMaterial({color:0x0c0c0f, roughness:0.9}));
    floor.rotation.x = -Math.PI/2; floor.position.y = 0; scene.add(floor);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.15, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 0.8;
    controls.maxDistance = 6;

    // Bloom エフェクト
    const composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new THREE.UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      0.9, // strength
      0.4, // radius
      0.12 // threshold
    );
    composer.addPass(bloomPass);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      composer.render();
    }
    animate();

    window.addEventListener('resize', function () {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

  });
  </script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Glass Sphere — Time-based Transparency</title>

<!-- Import map -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/": "https://unpkg.com/three@0.162.0/"
  }
}
</script>

<style>
  html,body { margin:0; padding:0; height:100%; background:#05060a; overflow:hidden; }
  #container { width:100%; height:100%; }
</style>
</head>
<body>
<div id="container"></div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

// === シーン・カメラ・レンダラー ===
const container = document.getElementById('container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.05, 100);
camera.position.set(0, 0.4, 2.5);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
container.appendChild(renderer.domElement);

// === 背景グラデーション ===
const bgMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: {
    topColor: { value: new THREE.Color('#cce7ff') },
    bottomColor: { value: new THREE.Color('#00111a') }
  },
  vertexShader: `
    varying vec3 vPos;
    void main(){
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    varying vec3 vPos;
    void main(){
      float t = (vPos.y + 40.0)/80.0;
      vec3 c = mix(bottomColor, topColor, smoothstep(0.0,1.0,t));
      gl_FragColor = vec4(c, 1.0);
    }
  `
});
scene.add(new THREE.Mesh(new THREE.SphereGeometry(40,32,32), bgMat));

// === ガラス球 ===
const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0,
  roughness: 0.05,
  transmission: 0.95,
  thickness: 0.25,
  ior: 1.52,
  clearcoat: 1.0,
  clearcoatRoughness: 0.03,
  transparent: true,
  side: THREE.DoubleSide
});
const glassMesh = new THREE.Mesh(new THREE.SphereGeometry(1, 96, 96), glassMat);
scene.add(glassMesh);

// === ライト ===
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
dirLight.position.set(5, 10, 5);
scene.add(dirLight);

// === コントロール ===
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === 時間ベースのパラメータ更新関数 ===
function updateGlassMaterialByTime() {
  const now = new Date();
  const nyHour = new Intl.DateTimeFormat('en-US', {
    timeZone: 'America/New_York',
    hour: 'numeric',
    hour12: false
  }).format(now);
  const hour = parseInt(nyHour, 10) + now.getMinutes() / 60;

  // 0〜24h → 0〜2π
  const t = (hour / 24) * Math.PI * 2;

  // cos波: 0h→ぼかし強い, 12h→透明感強い
  const transparency = 0.7 + 0.25 * Math.cos(t + Math.PI); // transmission
  const rough = 0.2 - 0.15 * Math.cos(t + Math.PI);         // roughness
  const coat = 0.8 + 0.2 * Math.cos(t);                     // clearcoat
  const coatRough = 0.1 - 0.08 * Math.cos(t + Math.PI/2);   // clearcoatRoughness

  glassMat.transmission = transparency;     // 透明度
  glassMat.roughness = THREE.MathUtils.clamp(rough, 0, 1); // 表面のぼかし
  glassMat.clearcoat = coat;                // 輝きの強さ
  glassMat.clearcoatRoughness = THREE.MathUtils.clamp(coatRough, 0, 1);

  // デバッグ用ログ（必要なければ消してください）
  // console.log(`Hour: ${hour.toFixed(2)}, Transmission: ${glassMat.transmission.toFixed(2)}, Roughness: ${glassMat.roughness.toFixed(2)}`);
}

// === アニメーション ===
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  updateGlassMaterialByTime();
  renderer.render(scene, camera);
}
animate();

// === リサイズ ===
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

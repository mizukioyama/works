<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>鉄球オーラ表現</title>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<style>
  body { margin:0; background:#111; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

// === 基本セットアップ ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === 環境光 ===
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
scene.add(new THREE.AmbientLight(0xffffff,0.5));
const dir = new THREE.DirectionalLight(0xffffff,1.2);
dir.position.set(3,3,5);
scene.add(dir);

// === ガラス球 ===
const glassMat = new THREE.MeshPhysicalMaterial({
  transmission: 0.5,
  transparent: true,
  roughness: 0.5,
  metalness: 0.0,
  ior: 1.5,
  thickness: 0.6,
  clearcoat: 1.0,
  clearcoatRoughness: 0.3
});
const glassMesh = new THREE.Mesh(new THREE.SphereGeometry(1,64,64), glassMat);
scene.add(glassMesh);

// === 鉄球 ===
const ironMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 1.0,
  roughness: 0.08,
  envMapIntensity: 1.3,
  clearcoat: 1.0,
  clearcoatRoughness: 0.03
});
const ironMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3,128,128), ironMat);
scene.add(ironMesh);

// === オーラ（鉄球の周囲のグロー） ===
const auraGeo = new THREE.SphereGeometry(0.45, 64, 64);
const auraMat = new THREE.ShaderMaterial({
  transparent: true,
  blending: THREE.AdditiveBlending,
  side: THREE.BackSide,
  uniforms: {
    time: { value: 0.0 }
  },
  vertexShader: `
    varying vec3 vPos;
    void main() {
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float time;
    varying vec3 vPos;
    void main() {
      float intensity = 0.6 + 0.4*sin(length(vPos)*5.0 - time*2.0);
      vec3 color = vec3(0.5 + 0.5*sin(time+vPos.x*3.0),
                        0.5 + 0.5*sin(time+vPos.y*3.0+2.0),
                        0.5 + 0.5*sin(time+vPos.z*3.0+4.0));
      gl_FragColor = vec4(color * intensity, 0.6);
    }
  `
});
const auraMesh = new THREE.Mesh(auraGeo, auraMat);
ironMesh.add(auraMesh); // 鉄球にまとわりつくように追加

// === Bloomエフェクト ===
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene,camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.5, 0.4, 0.85);
composer.addPass(bloomPass);

// === 時間管理 ===
const startTime = Date.now();

// === アニメーション ===
function animate(){
  requestAnimationFrame(animate);
  const elapsed = (Date.now()-startTime)/1000;

  // 鉄球回転
  ironMesh.rotation.y += 0.002;
  ironMesh.rotation.x += 0.001;

  // ガラス球の透明化（60秒で透明）
  const p = Math.min(elapsed/60,1);
  glassMat.roughness = 0.5*(1-p);
  glassMat.transmission = 0.5+0.5*p;
  glassMat.clearcoatRoughness = 0.3*(1-p);

  // オーラの時間更新
  auraMat.uniforms.time.value = elapsed;

  controls.update();
  composer.render();
}
animate();

// === リサイズ ===
window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

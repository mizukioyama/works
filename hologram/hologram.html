<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>メタリック鉄球＋ガラス球＋虹色オーラ＋ホログラムリング</title>
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<style>
  html,body { height:100%; margin:0; background:#000; }
  canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { RGBELoader } from "three/addons/loaders/RGBELoader.js";

// --- 基本 ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111218); // 幻想的な暗灰
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0, 4);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2; // 少し明るく
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

// ライト
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(3,4,5);
scene.add(dir);

// --- 反射キャプチャ用 CubeCamera ---
const cubeRT = new THREE.WebGLCubeRenderTarget(512, {
  format: THREE.RGBAFormat,
  generateMipmaps: true,
  minFilter: THREE.LinearMipmapLinearFilter
});
const cubeCamera = new THREE.CubeCamera(0.1, 100, cubeRT);
scene.add(cubeCamera);

// --- 共有変数 ---
let glassMesh, ironMesh;
let hdrEnv = null; // HDRIテクスチャ参照を保持

// --- ガラス球 ---
function makeGlass() {
  const geo = new THREE.SphereGeometry(1.0, 64, 64);
  const mat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 1.4,
  roughness: 0.0,
  envMapIntensity: 1.5
});
  glassMesh = new THREE.Mesh(geo, mat);
  glassMesh.renderOrder = 2;
  scene.add(glassMesh);
}
makeGlass();

// --- クローム鉄球（鏡面シルバー） ---
function makeIron() {
  const radius = 0.8;
  const geo = new THREE.SphereGeometry(radius, 128, 128);
  const mat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,          // 白（反射のみで色が付く）
    metalness: 1.0,           // 完全金属
    roughness: 0.5,           // 鏡面
    envMap: cubeRT.texture,   // 動的反射（後でHDRI背景も写し込む）
    envMapIntensity: 3.0,
    clearcoat: 1.0,
    clearcoatRoughness: 0.0
  });
  ironMesh = new THREE.Mesh(geo, mat);
  ironMesh.renderOrder = 1;
  scene.add(ironMesh);
}
makeIron();

// --- 虹色リング（既存演出のまま） ---
function createRainbowRing(inner, outer, seg=256) {
  const geo = new THREE.RingGeometry(inner, outer, seg);
  const pos = geo.attributes.position;
  const colors = [];
  for (let i=0; i<pos.count; i++){
    const x = pos.getX(i), y = pos.getY(i);
    const ang = (Math.atan2(y,x) + Math.PI) / (2*Math.PI);
    const c = new THREE.Color();
    c.setHSL(ang, 1.0, 0.5);
    colors.push(c.r, c.g, c.b);
  }
  geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
  const mat = new THREE.MeshBasicMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.75,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = Math.PI / 2;
  return mesh;
}
const ringGroup = new THREE.Group();
for (let i=0; i<4; i++){
  const r = createRainbowRing(0.55 + i*0.06, 0.62 + i*0.06);
  ringGroup.add(r);
}
scene.add(ringGroup);

// --- オーラ（Fresnel glow） ---
const auraGeo = new THREE.SphereGeometry(0.75, 64, 64);
const auraMat = new THREE.ShaderMaterial({
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false,
  uniforms: {
    glowColor: { value: new THREE.Color(0xffffff) },
    intensity: { value: 1.2 },
    power: { value: 2.0 }
  },
  vertexShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main(){
      vNormal = normalize(normalMatrix * normal);
      vec4 wp = modelMatrix * vec4(position, 1.0);
      vWorldPos = wp.xyz;
      gl_Position = projectionMatrix * viewMatrix * wp;
    }
  `,
  fragmentShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    uniform vec3 glowColor;
    uniform float intensity;
    uniform float power;
    void main(){
      vec3 V = normalize(cameraPosition - vWorldPos);
      float fres = pow(1.0 - max(dot(vNormal, V), 0.0), power);
      gl_FragColor = vec4(glowColor * fres * intensity, fres * intensity);
    }
  `
});
const auraMesh = new THREE.Mesh(auraGeo, auraMat);
scene.add(auraMesh);

// --- 背景ホログラムリング（鉄球より外側から） ---
const holoGroup = new THREE.Group();
scene.add(holoGroup);

function makeHoloRing(radius, thickness, color){
  const geo = new THREE.RingGeometry(radius, radius+thickness, 128);
  const mat = new THREE.MeshBasicMaterial({
    color: color,
    transparent: true,
    opacity: 0.6,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = Math.PI/2;
  return mesh;
}

const MAX_RINGS = 12;
for (let i=0; i<MAX_RINGS; i++){
  const r = makeHoloRing(1.2, 0.08, new THREE.Color(0x66ccff)); // ★ 半径1.2以上
  r.userData = {
    startTime: Math.random()*3,
    speed: 0.06 + Math.random()*0.04
  };
  holoGroup.add(r);
}

// --- HDRI ---
new RGBELoader()
    .setPath('https://cdn.jsdelivr.net/gh/mrdoob/three.js@dev/examples/textures/equirectangular/')
  .load('royal_esplanade_1k.hdr', (tex) => {
    tex.mapping = THREE.EquirectangularReflectionMapping;
    hdrEnv = tex;
    scene.environment = tex; // ライティング用
    ironMesh.material.envMap = tex;   // ← HDRI を直接反射に使用
    ironMesh.material.envMapIntensity = 1.5;
    ironMesh.material.needsUpdate = true;
  });

// --- 更新処理 ---
function updateGlass(){
  if (!glassMesh) return;
  const elapsed = (Date.now() - startTime) / 1000;
  const p = Math.min(elapsed / 30, 1.0); // 30秒で透明化
  const m = glassMesh.material;
  m.roughness = 0.4 * (1-p);
  m.transmission = 0.5 + 0.5 * p;
  m.clearcoatRoughness = 0.3 * (1-p);
  m.opacity = 1.0 - p;
  m.needsUpdate = true;
}

function updateBackground(){
  const t = (Date.now() - startTime) / 1000;

  // 虹リング
  ringGroup.children.forEach((r,i) => {
    r.rotation.z += 0.0018 * (i % 2 ? -1 : 1);
    r.material.opacity = 0.55 + 0.25 * Math.sin(t*2 + i);
  });

  // オーラ
  auraMesh.position.copy(ironMesh.position);
  auraMesh.material.uniforms.intensity.value = 1.0 + 0.6 * Math.sin(t*2.5);
  auraMesh.scale.setScalar(1.0 + 0.02*Math.sin(t*1.7));

  // ホログラムリング：拡大・フェード（波紋）
  holoGroup.children.forEach((ring,i)=>{
    const data = ring.userData;
    const elapsed = t - data.startTime;
    if (elapsed < 0) return;

    const scale = 1.0 + elapsed * data.speed * 6.0;
    ring.scale.setScalar(scale);

    const fade = Math.max(1.0 - elapsed*0.5, 0.0);
    ring.material.opacity = fade * 0.6;

    // シアン〜マゼンタ寄りの色相を揺らす
    const hue = (200 + Math.sin((t+i)*0.5)*40) / 360;
    ring.material.color.setHSL(hue, 1.0, 0.6);

    if (fade <= 0.0){
      data.startTime = t + Math.random()*1.5;
      ring.scale.setScalar(1.0);
    }
  });
}

// --- 時間管理 ---
const startTime = Date.now();

// --- animate ---
function animate(){
  requestAnimationFrame(animate);

  if (ironMesh){
    // クローム反射用にキューブカメラを鉄球位置で更新
    cubeCamera.position.copy(ironMesh.position);

    // HDRIを背景にしてキャプチャ（リッチな映り込み用）
    const prevBg = scene.background;
    const prevGlassVisible = glassMesh ? glassMesh.visible : true;
    ironMesh.visible = false;
    if (glassMesh) glassMesh.visible = false; // ガラスの屈折で濁らないよう一時非表示
    if (hdrEnv) scene.background = hdrEnv;

    cubeCamera.update(renderer, scene);

    // 復元
    if (glassMesh) glassMesh.visible = prevGlassVisible;
    scene.background = prevBg;
    ironMesh.visible = true;

    // 回転
    ironMesh.rotation.y += 0.01;
    ironMesh.rotation.x += 0.005;
  }

  updateGlass();
  updateBackground();
  renderer.render(scene, camera);
}
animate();

// --- resize ---
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Glass Sphere — Day/Night & Moon Auto (US, 24h)</title>

<!-- importmap for three -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/": "https://unpkg.com/three@0.162.0/",
    "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm"
  }
}
</script>

<!-- SunCalc & Luxon (non-module globals) -->
<script src="https://cdn.jsdelivr.net/npm/suncalc@1.9.0/suncalc.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@3.6.0/build/global/luxon.min.js"></script>

<style>
  html,body{height:100%;margin:0;background:#05060a;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","メイリオ",sans-serif}
  #container{width:100%;height:100vh;position:relative}
  #uiPanel{
    position:fixed; right:12px; top:12px; width:320px; z-index:40;
    background:rgba(0,0,0,0.45); padding:12px; border-radius:10px;
    backdrop-filter: blur(6px); font-size:13px;
  }
  label{display:block;margin-top:6px;font-size:12px;color:#cfd8e3}
  select,input{width:100%;padding:6px;margin-top:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#fff}
  button{margin-top:8px;padding:8px 10px;border-radius:8px;border:none;background:#2196f3;color:#fff;cursor:pointer}
  #info{margin-top:10px;font-size:13px;color:#e6eef8}
  .small{font-size:12px;color:#9fb0cf}
</style>
</head>
<body>
<div id="container"></div>

<div id="uiPanel">
  <div style="font-weight:600;margin-bottom:6px">Day/Night Auto — US (24h)</div>

  <label>都市プリセット（米国）</label>
  <select id="citySelect">
    <option value='{"name":"New York, NY","lat":40.7128,"lon":-74.0060,"tz":"America/New_York"}'>New York (America/New_York)</option>
    <option value='{"name":"Los Angeles, CA","lat":34.0522,"lon":-118.2437,"tz":"America/Los_Angeles"}'>Los Angeles (America/Los_Angeles)</option>
    <option value='{"name":"Chicago, IL","lat":41.8781,"lon":-87.6298,"tz":"America/Chicago"}'>Chicago (America/Chicago)</option>
    <option value='{"name":"Denver, CO","lat":39.7392,"lon":-104.9903,"tz":"America/Denver"}'>Denver (America/Denver)</option>
    <option value='{"name":"Anchorage, AK","lat":61.2181,"lon":-149.9003,"tz":"America/Anchorage"}'>Anchorage (America/Anchorage)</option>
    <option value='{"name":"Honolulu, HI","lat":21.3069,"lon":-157.8583,"tz":"Pacific/Honolulu"}'>Honolulu (Pacific/Honolulu)</option>
    <option value='{"name":"Phoenix, AZ","lat":33.4484,"lon":-112.0740,"tz":"America/Phoenix"}'>Phoenix (America/Phoenix)</option>
  </select>

  <label>緯度,経度（手入力で都市上書き）</label>
  <input id="latInput" placeholder="lat (例: 40.7128)" type="number" step="0.0001"/>
  <input id="lonInput" placeholder="lon (例: -74.0060)" type="number" step="0.0001"/>

  <label>モード</label>
  <select id="mode">
    <option value="realtime">Real-time（現在時刻を反映）</option>
    <option value="simulate">Simulate 24h</option>
  </select>

  <label>速度（Simulate 時の速さ、1 = 実時間、24 = 24倍）</label>
  <input id="speed" type="range" min="0.1" max="240" step="0.1" value="60"/>

  <div style="display:flex;gap:8px">
    <button id="playBtn">Play</button>
    <button id="pauseBtn">Pause</button>
    <button id="nowBtn">Now</button>
  </div>

  <div id="info">
    <div id="locName" class="small"></div>
    <div id="sunTimes" class="small"></div>
    <div id="moonTimes" class="small"></div>
    <div id="clock" class="small" style="margin-top:6px"></div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import GUI from "lil-gui";

// --- basics: renderer, scene, camera
const container = document.getElementById('container');
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, container.clientWidth/container.clientHeight, 0.05, 100);
camera.position.set(0,0.8,3);
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// --- environment (simple gradient sphere)
const envMat = new THREE.ShaderMaterial({
  side: THREE.BackSide,
  uniforms: {
    topColor: { value: new THREE.Color('#ffd7e6') },
    bottomColor: { value: new THREE.Color('#7be7ff') }
  },
  vertexShader: `varying vec3 vPos; void main(){ vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
  fragmentShader: `uniform vec3 topColor; uniform vec3 bottomColor; varying vec3 vPos; void main(){ float t = (vPos.y+40.0)/80.0; vec3 c = mix(bottomColor, topColor, smoothstep(0.0,1.0,t)); gl_FragColor = vec4(c,1.0); }`
});
scene.add(new THREE.Mesh(new THREE.SphereGeometry(40,32,32), envMat));

// --- ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshStandardMaterial({ color:0x07070a, roughness:0.5 }));
ground.rotation.x = -Math.PI/2; ground.position.y = -1.05; scene.add(ground);

// --- realistic glass sphere (high detail)
const sphereGeo = new THREE.SphereGeometry(1.0, 192, 192);
const glassMat = new THREE.MeshPhysicalMaterial({
  color:0xffffff, metalness:0, roughness:0.02, transmission:1.0, thickness:0.18, ior:1.52, clearcoat:1.0, clearcoatRoughness:0.02, envMapIntensity:1.0, side:THREE.DoubleSide
});
const glass = new THREE.Mesh(sphereGeo, glassMat);
scene.add(glass);

// --- internal subtle shell to hint thickness
const inner = new THREE.Mesh(new THREE.SphereGeometry(0.88,128,128), new THREE.MeshPhysicalMaterial({ color:0xffffff, roughness:0.35, transmission:0.8, thickness:0.02, opacity:0.65, transparent:true }));
scene.add(inner);

// --- small particles for mist
const N = 12000;
const pos = new Float32Array(N*3);
for(let i=0;i<N;i++){
  const r = Math.cbrt(Math.random()) * 0.9;
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);
  pos[3*i] = r * Math.sin(phi) * Math.cos(theta);
  pos[3*i+1] = r * Math.sin(phi) * Math.sin(theta);
  pos[3*i+2] = r * Math.cos(phi);
}
const pgeo = new THREE.BufferGeometry();
pgeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
const pmat = new THREE.PointsMaterial({ size: 0.008, color:0xffffff, transparent:true, opacity:0.12, depthWrite:false });
const points = new THREE.Points(pgeo, pmat);
scene.add(points);

// --- lights: directional for sun, ambient, moon light
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);

const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
sunLight.castShadow = false;
scene.add(sunLight);

const moonLight = new THREE.DirectionalLight(0x9fbffb, 0.0);
scene.add(moonLight);

// --- postprocess (bloom)
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.5, 0.6, 0.85);
composer.addPass(bloom);

// --- UI elements
const citySelect = document.getElementById('citySelect');
const latInput = document.getElementById('latInput');
const lonInput = document.getElementById('lonInput');
const modeSelect = document.getElementById('mode');
const speedInput = document.getElementById('speed');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const nowBtn = document.getElementById('nowBtn');
const locNameEl = document.getElementById('locName');
const sunTimesEl = document.getElementById('sunTimes');
const moonTimesEl = document.getElementById('moonTimes');
const clockEl = document.getElementById('clock');

let playing = false;
let simulateSpeed = parseFloat(speedInput.value);
let simTime = Date.now(); // ms
let mode = modeSelect.value;

// default location (NY)
let current = JSON.parse(citySelect.value);

// set lat/lon inputs to current
latInput.value = current.lat;
lonInput.value = current.lon;
locNameEl.textContent = `${current.name} — timezone: ${current.tz}`;

// helpers: format time in city's timezone using Luxon
const { DateTime } = luxon;
function fmtDate(dt) {
  return dt.toLocaleString(DateTime.TIME_24_WITH_SECONDS);
}

// compute Sun/Moon and update lighting based on date & lat/lon
function updateForDate(date, lat, lon, tz){
  // Sun
  const sunPos = SunCalc.getPosition(date, lat, lon); // returns azimuth, altitude (radians)
  const sunAz = sunPos.azimuth; const sunAlt = sunPos.altitude;

  // Moon
  const moonPos = SunCalc.getMoonPosition(date, lat, lon);
  const moonAlt = moonPos.altitude; const moonAz = moonPos.azimuth;

  // Rise/set times
  const times = SunCalc.getTimes(date, lat, lon);
  const moonTimes = SunCalc.getMoonTimes(date, lat, lon, true); // returns rise/set where available

  // Update UI times (formatted to tz)
  const dtLocal = DateTime.fromJSDate(date).setZone(tz);
  locNameEl.textContent = `${current.name} — ${dtLocal.toFormat("yyyy-LL-dd") } (${tz})`;

  const sunrise = times.sunrise ? DateTime.fromJSDate(times.sunrise).setZone(tz).toFormat('HH:mm:ss') : '—';
  const sunset  = times.sunset  ? DateTime.fromJSDate(times.sunset).setZone(tz).toFormat('HH:mm:ss') : '—';
  sunTimesEl.textContent = `Sunrise: ${sunrise}  /  Sunset: ${sunset}`;

  const mRise = (moonTimes.rise ? DateTime.fromJSDate(moonTimes.rise).setZone(tz).toFormat('HH:mm:ss') : '—');
  const mSet  = (moonTimes.set  ? DateTime.fromJSDate(moonTimes.set).setZone(tz).toFormat('HH:mm:ss') : '—');
  moonTimesEl.textContent = `Moonrise: ${mRise}  /  Moonset: ${mSet}`;

  // determine if sun is above horizon
  const sunAbove = sunAlt > 0;

  // Map sun altitude [-PI/2..PI/2] -> intensity/color/ambient/exposure
  // color temp warm at sunrise/sunset, neutral midday
  const sunNorm = THREE.MathUtils.clamp((sunAlt / (Math.PI/2)), -1, 1); // -1..1
  // intensity: when sun above: 0.0..1.6, when below: 0.0..0.12 (night residual)
  const sunIntensity = sunAbove ? THREE.MathUtils.lerp(0.2, 1.6, Math.pow(Math.max(0, sunNorm), 0.8)) : 0.05;
  // color: mix warm to cool
  let sunColor;
  if (sunAbove){
    // earlier (low alt) -> warm #ffb27a, mid -> white
    const t = THREE.MathUtils.clamp((sunAlt / 0.6), 0, 1);
    sunColor = new THREE.Color().lerpColors(new THREE.Color(0xffb27a), new THREE.Color(0xffffff), t);
  } else {
    sunColor = new THREE.Color(0x222a3a); // night slight tint
  }

  // apply sun directional orientation: convert spherical (azimuth, altitude) to vector
  // SunCalc.azimuth is measured from south to west? (azimuth from North?)
  // We'll use a common conversion: x = cos(alt)*sin(az), y = sin(alt), z = cos(alt)*cos(az) and invert for THREE directional light.
  const az = sunAz; const alt = sunAlt;
  const x = Math.cos(alt) * Math.sin(az);
  const y = Math.sin(alt);
  const z = Math.cos(alt) * Math.cos(az);
  const sunDir = new THREE.Vector3(x, y, z).multiplyScalar(-1); // point light from sky to scene
  sunLight.position.copy(sunDir.clone().multiplyScalar(10));
  sunLight.color.copy(sunColor);
  sunLight.intensity = sunIntensity;

  // Moon handling: weaker bluish light when above horizon
  const moonAbove = moonAlt > 0;
  const moonIntensity = moonAbove ? THREE.MathUtils.lerp(0.02, 0.35, THREE.MathUtils.clamp(moonAlt / 0.5, 0, 1)) : 0.0;
  const mAz = moonPos.azimuth; const mAlt = moonPos.altitude;
  const mx = Math.cos(mAlt) * Math.sin(mAz);
  const my = Math.sin(mAlt);
  const mz = Math.cos(mAlt) * Math.cos(mAz);
  moonLight.position.copy(new THREE.Vector3(mx, my, mz).multiplyScalar(-10));
  moonLight.color.setHex(0x9fbffb);
  moonLight.intensity = moonIntensity;

  // ambient: low at night, stronger in day
  ambient.intensity = THREE.MathUtils.lerp(0.08, 0.6, THREE.MathUtils.clamp(sunIntensity / 1.6, 0, 1));

  // exposure / bloom adjustments
  renderer.toneMappingExposure = THREE.MathUtils.lerp(0.3, 1.2, THREE.MathUtils.clamp(sunIntensity/1.6, 0, 1));
  bloom.strength = sunAbove ? THREE.MathUtils.lerp(0.12, 0.9, THREE.MathUtils.clamp(sunIntensity/1.6, 0, 1)) : 0.4;

  // environment colors (background gradient) shift: night -> bluish, day -> warm top
  if (sunAbove){
    envMat.uniforms.topColor.value.set('#fff6e8');
    envMat.uniforms.bottomColor.value.set('#dff4ff');
  } else {
    envMat.uniforms.topColor.value.set('#051433');
    envMat.uniforms.bottomColor.value.set('#001020');
  }

  // glass material tweak: at night increase roughness a bit, reduce env intensity
  glassMat.roughness = sunAbove ? 0.02 : 0.08;
  glassMat.envMapIntensity = sunAbove ? 1.0 : 0.6;
}

// --- simulation / realtime clock
let lastTick = performance.now();
function tick(now){
  const dt = (now - lastTick)/1000;
  lastTick = now;
  if (playing){
    if (mode === 'realtime'){
      simTime = Date.now();
    } else {
      // simulate: advance simTime by dt * speed
      simTime += dt * 1000 * simulateSpeed;
    }
  }
  // Evaluate for current simTime in timezone of selected city (we just compute positions using Date(simTime))
  const date = new Date(simTime);
  const lat = parseFloat(latInput.value) || current.lat;
  const lon = parseFloat(lonInput.value) || current.lon;
  const tz = current.tz;
  updateForDate(date, lat, lon, tz);

  // update clock display in city's tz
  const dtLocal = DateTime.fromMillis(simTime).setZone(tz);
  clockEl.textContent = `Local time: ${dtLocal.toFormat('yyyy-LL-dd HH:mm:ss')} (${tz})`;

  // animate scene objects subtly
  const t = simTime / 1000;
  glass.rotation.y = t * 0.02;
  inner.rotation.y = -t * 0.016;
  points.rotation.y = t * 0.01;

  // render
  composer.render();

  requestAnimationFrame(tick);
}

// --- UI events
citySelect.addEventListener('change', ()=>{
  current = JSON.parse(citySelect.value);
  latInput.value = current.lat; lonInput.value = current.lon;
  locNameEl.textContent = `${current.name} — timezone: ${current.tz}`;
});

latInput.addEventListener('change', ()=> {
  current = Object.assign({}, current, { lat: parseFloat(latInput.value), lon: parseFloat(lonInput.value) });
});

lonInput.addEventListener('change', ()=> {
  current = Object.assign({}, current, { lat: parseFloat(latInput.value), lon: parseFloat(lonInput.value) });
});

modeSelect.addEventListener('change', ()=> { mode = modeSelect.value; });

speedInput.addEventListener('input', ()=> { simulateSpeed = parseFloat(speedInput.value); });

playBtn.addEventListener('click', ()=> { playing = true; });
pauseBtn.addEventListener('click', ()=> { playing = false; });
nowBtn.addEventListener('click', ()=> { simTime = Date.now(); });

/* start paused, then auto-play realtime */
playing = true; mode = 'realtime'; lastTick = performance.now(); requestAnimationFrame(tick);

// --- resize handling
window.addEventListener('resize', ()=>{
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h); composer.setSize(w,h);
});

</script>
</body>
</html>

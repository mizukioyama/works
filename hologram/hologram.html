<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>ガラス球＋鉄球＋虹色リング</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<style>
  html, body { margin:0; height:100%; background:#f0f0f0; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

// === 基本セットアップ ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 4);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xf0f0f0);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === 環境光 ===
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(3,3,5);
scene.add(dir);

// === ガラス球 ===
const glassMesh = new THREE.Mesh(
  new THREE.SphereGeometry(1, 64, 64),
  new THREE.MeshPhysicalMaterial({
    transmission: 0.7,
    transparent: true,
    roughness: 0.15,
    metalness: 0.0,
    ior: 1.5,
    thickness: 0.6,
    clearcoat: 1.0,
    clearcoatRoughness: 0.1
  })
);
scene.add(glassMesh);

// === メタリック鉄球 ===
const ironRadius = 0.3;
const ironMesh = new THREE.Mesh(
  new THREE.SphereGeometry(ironRadius, 128, 128),
  new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 1.0,
    roughness: 0.08,
    envMapIntensity: 1.4,
    clearcoat: 1.0,
    clearcoatRoughness: 0.03
  })
);
scene.add(ironMesh);

// === オーラ（鉄球周囲のグロー） ===
const auraMaterial = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uColor: { value: new THREE.Color(0x66ccff) },
    uIntensity: { value: 0.8 },
    uPower: { value: 2.2 }
  },
  vertexShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main(){
      vNormal = normalize(normalMatrix * normal);
      vec4 wp = modelMatrix * vec4(position,1.0);
      vWorldPos = wp.xyz;
      gl_Position = projectionMatrix * viewMatrix * wp;
    }
  `,
  fragmentShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    uniform vec3 uColor;
    uniform float uIntensity;
    uniform float uPower;
    void main(){
      vec3 V = normalize(cameraPosition - vWorldPos);
      float fres = pow(1.0 - max(dot(normalize(vNormal), V), 0.0), uPower);
      gl_FragColor = vec4(uColor, fres * uIntensity);
    }
  `
});
const auraMesh = new THREE.Mesh(
  new THREE.SphereGeometry(ironRadius * 1.35, 96, 96),
  auraMaterial
);
scene.add(auraMesh);

// === 背景リング（虹色のフレアリング） ===
function createRainbowRing(innerR=1.2, outerR=1.4) {
  const geo = new THREE.RingGeometry(innerR, outerR, 128);
  const colors = [];
  const pos = geo.attributes.position;
  for (let i=0; i<pos.count; i++) {
    const x = pos.getX(i), y = pos.getY(i);
    const angle = (Math.atan2(y,x) + Math.PI) / (2*Math.PI);
    const color = new THREE.Color();
    color.setHSL(angle, 1.0, 0.5);
    colors.push(color.r, color.g, color.b);
  }
  geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));

  const mat = new THREE.MeshBasicMaterial({
    vertexColors: true,
    side: THREE.DoubleSide,
    transparent: true,
    opacity: 0.65,
    blending: THREE.AdditiveBlending
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.rotation.x = Math.PI/2;
  return mesh;
}

const rainbowRing1 = createRainbowRing(1.25, 1.5);
const rainbowRing2 = createRainbowRing(1.55, 1.8);
scene.add(rainbowRing1);
scene.add(rainbowRing2);

// === アニメーション ===
function animate(t) {
  requestAnimationFrame(animate);

  // 鉄球回転
  ironMesh.rotation.y = t*0.0003;
  ironMesh.rotation.x = t*0.00015;

  // オーラ追従
  auraMesh.position.copy(ironMesh.position);

  // 虹色リングの回転（交互方向）
  rainbowRing1.rotation.z = t*0.0004;
  rainbowRing2.rotation.z = -t*0.0003;

  controls.update();
  renderer.render(scene, camera);
}
animate();

// === リサイズ ===
window.addEventListener("resize", ()=>{
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
});
</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Realistic Glass Sphere (Three.js, CDN + importmap)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/": "https://unpkg.com/three@0.162.0/",
    "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm"
  }
}
</script>

<style>
  html,body{height:100%;margin:0;background:#0b0b0b}
  #app{width:100vw;height:100vh;overflow:hidden;display:block;position:relative}
  #note{position:fixed;left:12px;top:12px;z-index:20;color:#ddd;background:rgba(0,0,0,0.35);padding:8px;border-radius:8px;font-size:13px}
</style>
</head>
<body>
<div id="app"><div id="note">ドラッグで回転・ホイールでズーム — カメラ/マテリアルはGUIで調整</div></div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import GUI from "lil-gui";

const container = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b0b0b);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.05, 100);
camera.position.set(0, 0.8, 3.2);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 1.2;
controls.maxDistance = 10;

// ---------- HDR-like environment using example cube (SwedishRoyalCastle)
// 6 faces are hosted on threejs.org; using CubeTextureLoader + PMREMGenerator to create high-quality envMap
const loader = new THREE.CubeTextureLoader();
const basePath = 'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/'; // stable example set
const urls = [
  basePath + 'px.jpg',
  basePath + 'nx.jpg',
  basePath + 'py.jpg',
  basePath + 'ny.jpg',
  basePath + 'pz.jpg',
  basePath + 'nz.jpg'
];

loader.load(urls, (cubeTex) => {
  // convert to PMREM for correct IBL
  const pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  const envMap = pmrem.fromCubemap(cubeTex).texture;
  scene.environment = envMap; // for PBR materials
  scene.background = cubeTex; // optional: show environment behind
  pmrem.dispose();
});

// ---------- subtle ground for contact/reflect
const groundGeo = new THREE.PlaneGeometry(20, 20);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x0b0b0b, roughness: 0.45, metalness: 0.05 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.position.y = -1.05;
scene.add(ground);

// ---------- glass sphere (high-poly) ----------
const sphereGeo = new THREE.SphereGeometry(1.0, 192, 192);

// Realistic physical material settings
const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.0,
  roughness: 0.02,
  transmission: 1.0,      // 完全透過（ガラス）
  thickness: 0.18,        // 厚さ（屈折の見え方に影響）
  ior: 1.52,              // ガラスっぽい屈折率
  specularIntensity: 1.2,
  specularColor: new THREE.Color(0xffffff),
  clearcoat: 1.0,
  clearcoatRoughness: 0.02,
  reflectivity: 0.9,      // ミラー寄りの反射も出す
  envMapIntensity: 1.0,
  transmissionSampler: true, // three r162+ 一部環境で有効（最適化）
  side: THREE.DoubleSide
});

const glassMesh = new THREE.Mesh(sphereGeo, glassMat);
glassMesh.position.set(0, 0, 0);
scene.add(glassMesh);

// ---------- small inner bubble to hint thickness (optional visual) ----------
const innerGeo = new THREE.SphereGeometry(0.88, 128, 128);
const innerMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.0,
  roughness: 0.38,
  transmission: 0.85,
  thickness: 0.02,
  ior: 1.0,
  transparent: true,
  opacity: 0.6
});
const innerMesh = new THREE.Mesh(innerGeo, innerMat);
scene.add(innerMesh);

// ---------- subtle rim light (emissive planes) to enhance silhouette ----------
const rimLightLeft = new THREE.PointLight(0xfff6e6, 0.6, 10);
rimLightLeft.position.set(-3, 2, 2);
scene.add(rimLightLeft);
const rimLightRight = new THREE.PointLight(0x7fdcff, 0.6, 10);
rimLightRight.position.set(3, -1.2, 2.8);
scene.add(rimLightRight);

// ---------- small decorative suspended mist (low-cost) ----------
const particleCount = 16000;
const pos = new Float32Array(particleCount*3);
for(let i=0;i<particleCount;i++){
  const r = Math.cbrt(Math.random()) * 0.9;
  const theta = Math.random() * Math.PI * 2;
  const phi = Math.acos(2*Math.random()-1);
  pos[3*i] = r * Math.sin(phi) * Math.cos(theta);
  pos[3*i+1] = r * Math.sin(phi) * Math.sin(theta);
  pos[3*i+2] = r * Math.cos(phi);
}
const pgeo = new THREE.BufferGeometry();
pgeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
const pmat = new THREE.PointsMaterial({ size: 0.008, color: 0xffffff, transparent:true, opacity:0.12, depthWrite:false });
const points = new THREE.Points(pgeo, pmat);
scene.add(points);

// ---------- postprocess ----------
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.4, 0.5, 0.85);
composer.addPass(bloom);

// ---------- GUI ----------
const gui = new GUI({ width: 320 });
const gglass = gui.addFolder('Glass');
gglass.add(glassMat, 'transmission', 0, 1, 0.01).name('transmission');
gglass.add(glassMat, 'thickness', 0, 1, 0.001).name('thickness');
gglass.add(glassMat, 'ior', 1.0, 2.5, 0.01).name('ior');
gglass.add(glassMat, 'roughness', 0, 1, 0.001).name('roughness');
gglass.add(glassMat, 'envMapIntensity', 0, 3, 0.01).name('envMapIntensity');
gglass.open();

const gscene = gui.addFolder('Scene');
gscene.add(renderer, 'toneMappingExposure', 0.2, 2.5, 0.01).name('Exposure');
gscene.add(bloom, 'strength', 0, 2.0, 0.01).name('Bloom');
gscene.open();

// ---------- animation ----------
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();
  // slight breathing for realism
  glassMesh.rotation.y = t * 0.08;
  innerMesh.rotation.y = -t * 0.06;
  points.rotation.y = t * 0.02;
  controls.update();
  composer.render();
}
animate();

// ---------- resize ----------
window.addEventListener('resize', onResize);
function onResize(){
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h); composer.setSize(w,h);
}
</script>
</body>
</html>

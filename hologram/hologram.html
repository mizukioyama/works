<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>鉄球＋ガラス球＋虹色リング</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<style>
  body { margin:0; background:#111; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

// === 基本セットアップ ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === 環境光 ===
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
scene.add(new THREE.AmbientLight(0xffffff,0.5));
const dir = new THREE.DirectionalLight(0xffffff,1.2);
dir.position.set(3,3,5);
scene.add(dir);

// === ガラス球 ===
const glassMat = new THREE.MeshPhysicalMaterial({
  transmission: 0.5,
  transparent: true,
  roughness: 0.5,
  metalness: 0.0,
  ior: 1.5,
  thickness: 0.6,
  clearcoat: 1.0,
  clearcoatRoughness: 0.3
});
const glassMesh = new THREE.Mesh(new THREE.SphereGeometry(1,64,64), glassMat);
scene.add(glassMesh);

// === 鉄球 ===
const ironMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 1.0,
  roughness: 0.08,
  envMapIntensity: 1.3,
  clearcoat: 1.0,
  clearcoatRoughness: 0.03
});
const ironMesh = new THREE.Mesh(new THREE.SphereGeometry(0.3,128,128), ironMat);
scene.add(ironMesh);

// === 背景リング ===
function createRainbowRing(innerR, outerR) {
  const geo = new THREE.RingGeometry(innerR, outerR, 128);
  const colors = [];
  const pos = geo.attributes.position;
  for (let i=0; i<pos.count; i++) {
    const x = pos.getX(i), y = pos.getY(i);
    const angle = (Math.atan2(y,x) + Math.PI)/(2*Math.PI);
    const c = new THREE.Color();
    c.setHSL(angle,1.0,0.5);
    colors.push(c.r,c.g,c.b);
  }
  geo.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));
  const mat = new THREE.MeshBasicMaterial({
    vertexColors:true,
    side:THREE.DoubleSide,
    transparent:true,
    opacity:0.8,
    blending:THREE.AdditiveBlending
  });
  const ring = new THREE.Mesh(geo, mat);
  ring.rotation.x = Math.PI/2;
  return ring;
}
const ring1 = createRainbowRing(1.25,1.5);
const ring2 = createRainbowRing(1.55,1.8);
scene.add(ring1, ring2);

// === Bloomエフェクト ===
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene,camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth,innerHeight), 1.2, 0.4, 0.85);
composer.addPass(bloomPass);

// === 時間管理 ===
const startTime = Date.now();

// === アニメーション ===
function animate(t){
  requestAnimationFrame(animate);
  const elapsed = (Date.now()-startTime)/1000;

  // 鉄球回転
  ironMesh.rotation.y += 0.002;
  ironMesh.rotation.x += 0.001;

  // ガラス球の透明化（60秒で透明）
  const p = Math.min(elapsed/60,1);
  glassMat.roughness = 0.5*(1-p);
  glassMat.transmission = 0.5+0.5*p;
  glassMat.clearcoatRoughness = 0.3*(1-p);

  // リング回転（交互）
  ring1.rotation.z += 0.002;
  ring2.rotation.z -= 0.0015;

  controls.update();
  composer.render();
}
animate();

// === リサイズ ===
window.addEventListener("resize",()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
  composer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>

<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Glass Sphere — Gradient Mist (Three.js)</title>
  <style>
    html,body{height:100%;margin:0;background:#05060a;color:#fff;font-family:Inter,system-ui,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN", "メイリオ", sans-serif}
    #container{width:100%;height:100%;overflow:hidden;position:relative}
    #ui{position:fixed;left:12px;top:12px;z-index:20;padding:10px;border-radius:10px;background:rgba(0,0,0,0.35);backdrop-filter:blur(6px);font-size:13px}
    #credits{position:fixed;right:12px;bottom:12px;z-index:20;color:rgba(255,255,255,0.6);font-size:12px}
    a {color:#9adcf7}
    /* small responsive tweak for mobile */
    @media (max-width:600px){#ui{font-size:12px;padding:8px}}
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="ui">ドラッグで回転・ホイールでズーム。<br>右上のGUIで調整できます。</div>
  <div id="credits">Created with Three.js — save as <code>index.html</code> and host on GitHub Pages</div>

  <script type="module">
  // Glass sphere with gradient fog / mist inside
  // Single-file demo meant to be dropped into a GitHub repo and served as-is (GitHub Pages, Netlify, etc.)

  import * as THREE from 'https://unpkg.com/three@0.160.1/build/three.module.js';
  import { OrbitControls } from 'https://unpkg.com/three@0.160.1/examples/jsm/controls/OrbitControls.js';
  import { EffectComposer } from 'https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.1/examples/jsm/postprocessing/UnrealBloomPass.js';
  import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm';

  // ---------- params / quick tuning ----------
  const params = {
    particleCount: 40000, // change for performance: try 80000 for very dense, 20000 for low-end
    innerRadius: 0.9,     // particles live inside this radius
    sphereRadius: 1.0,    // glass sphere radius
    basePointSize: 18.0,  // base size of particle sprites (px) — tune with devicePixelRatio
    mistOpacity: 0.8,
    speed: 0.6,           // animation speed multiplier
    swirl: 0.95,          // global swirl amplitude
    bloomStrength: 0.9,
    bloomRadius: 0.9,
    bloomThreshold: 0.0,
    paletteTop: '#ffd7e6',    // upper mist color
    paletteBottom: '#7be7ff', // lower mist color
  };

  // ---------- renderer / scene / camera ----------
  const container = document.getElementById('container');
  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.physicallyCorrectLights = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.setSize(container.clientWidth, container.clientHeight, false);
  container.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  // camera
  const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.05, 100);
  camera.position.set(0, 0.45, 2.8);

  // orbit
  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.minDistance = 1.6;
  controls.maxDistance = 6;

  // ---------- environment: large inverted sphere with vertical gradient ----------
  const envGeometry = new THREE.SphereGeometry(40, 32, 32);
  const envMaterial = new THREE.ShaderMaterial({
    side: THREE.BackSide,
    uniforms: {
      topColor: { value: new THREE.Color(params.paletteTop) },
      bottomColor: { value: new THREE.Color(params.paletteBottom) },
    },
    vertexShader: `varying vec3 vPos;
      void main(){ vPos = position; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
    fragmentShader: `uniform vec3 topColor; uniform vec3 bottomColor; varying vec3 vPos;
      void main(){ float t = (vPos.y + 40.0) / 80.0; vec3 c = mix(bottomColor, topColor, smoothstep(0.0,1.0,t)); gl_FragColor = vec4(c, 1.0); }`
  });
  const envMesh = new THREE.Mesh(envGeometry, envMaterial);
  scene.add(envMesh);

  // ---------- lights (colored, to give gradient highlights through glass) ----------
  const fill1 = new THREE.PointLight(0xffb7d6, 0.6, 6);
  fill1.position.set(-2.5, 1.6, 1.8);
  scene.add(fill1);
  const fill2 = new THREE.PointLight(0x8ee8ff, 0.6, 6);
  fill2.position.set(2.1, -1.1, 2.2);
  scene.add(fill2);

  // ---------- glass sphere ----------
  const glassMat = new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 0.0,
    roughness: 0.0,
    transmission: 0.95,
    thickness: 0.25,
    ior: 1.55,
    specularIntensity: 1.0,
    envMapIntensity: 1.0,
    clearcoat: 1.0,
    clearcoatRoughness: 0.03,
    transparent: true,
    side: THREE.DoubleSide,
  });
  const glassGeo = new THREE.SphereGeometry(params.sphereRadius, 96, 96);
  const glassMesh = new THREE.Mesh(glassGeo, glassMat);
  scene.add(glassMesh);

  // ---------- volumetric particles (GPU-like shader) ----------
  // We'll render particles as gl_Point sprites. Positions are computed in the vertex shader
  // from initial positions using a time-based curl-ish field (fast approximation).

  function createMistPoints(count){
    const geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(count * 3);
    const scales = new Float32Array(count);
    const seeds = new Float32Array(count);

    for(let i=0;i<count;i++){
      // uniform random inside sphere by sampling radius^3
      const u = Math.random();
      const r = Math.cbrt(u) * (params.innerRadius);
      const theta = Math.acos(2 * Math.random() - 1);
      const phi = Math.random() * Math.PI * 2.0;
      const x = r * Math.sin(theta) * Math.cos(phi);
      const y = r * Math.cos(theta);
      const z = r * Math.sin(theta) * Math.sin(phi);
      pos[3*i] = x;
      pos[3*i+1] = y;
      pos[3*i+2] = z;
      scales[i] = 0.4 + Math.random() * 1.6; // size variation
      seeds[i] = Math.random() * 437.0; // seed per-point
    }

    geometry.setAttribute('aInitPos', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('aScale', new THREE.BufferAttribute(scales, 1));
    geometry.setAttribute('aSeed', new THREE.BufferAttribute(seeds, 1));
    return geometry;
  }

  // GLSL simplex noise (Ashima) - kept compact but sufficient
  const simplex3D = `
    // Simplex 3D noise by Ian McEwan, Ashima Arts (slightly compacted)
    vec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}
    vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);} 
    vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
    float snoise(vec3 v){
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      vec3 i = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - 0.5;
      i = mod289(i);
      vec4 p = permute(permute(permute(
               i.z + vec4(0.0, i1.z, i2.z, 1.0))
             + i.y + vec4(0.0, i1.y, i2.y, 1.0))
             + i.x + vec4(0.0, i1.x, i2.x, 1.0));
      float n_ = 0.142857142857;
      vec3 ns = n_ * vec3(1.0, 1.0, 1.0);
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);
      vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
      vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);
      vec4 s0 = floor(b0) * 2.0 + 1.0;
      vec4 s1 = floor(b1) * 2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
      vec3 p0 = vec3(a0.x, a0.y, h.x);
      vec3 p1 = vec3(a0.z, a0.w, h.y);
      vec3 p2 = vec3(a1.x, a1.y, h.z);
      vec3 p3 = vec3(a1.z, a1.w, h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x;
      p1 *= norm.y;
      p2 *= norm.z;
      p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }
  `;

  const mistVS = `
    attribute vec3 aInitPos;
    attribute float aScale;
    attribute float aSeed;
    uniform float uTime;
    uniform float uSpeed;
    uniform float uSwirl;
    uniform float uPointSize;
    uniform float pixelRatio;
    varying vec3 vWorldPos;
    varying float vScale;
    // noise function included below
    ${simplex3D}
    void main(){
      // base coordinate moving slowly
      vec3 p = aInitPos;
      float t = uTime * uSpeed;
      // introduce layered noise for gentle swirling
      float n1 = snoise(p * 1.6 + vec3(t * 0.12 + aSeed));
      float n2 = snoise(p * 3.2 + vec3(-t * 0.08 + aSeed * 0.5));
      float n3 = snoise(p * 0.9 + vec3(t * 0.17 - aSeed * 0.3));
      // combine into an animated offset
      vec3 offset = vec3(
        sin(t * 0.6 + aSeed) * 0.35 * n1 + n2 * 0.18,
        cos(t * 0.5 + aSeed * 1.7) * 0.26 * n3,
        sin(t * 0.8 - aSeed) * 0.33 * n2
      );
      // push particles along their radial direction a little to create swirling volumes
      vec3 dir = normalize(p + vec3(0.0001));
      vec3 pos = p + offset * uSwirl * aScale * 0.9 * dir;

      // ensure they stay inside the sphere slightly (soft clamp)
      float r = length(pos);
      float maxR = ${params.innerRadius.toFixed(3)};
      if(r > maxR){ pos *= (maxR / r) * (0.98); }

      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
      gl_Position = projectionMatrix * mvPosition;
      // size attenuation so points appear consistent across devices
      float size = uPointSize * aScale * (pixelRatio);
      // perspective scale
      gl_PointSize = size * (1.0 / -mvPosition.z);

      vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
      vScale = aScale;
    }
  `;

  const mistFS = `
    precision highp float;
    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float uOpacity;
    uniform float uInnerRadius;
    varying vec3 vWorldPos;
    varying float vScale;

    void main(){
      // soft circular sprite
      vec2 uv = gl_PointCoord - vec2(0.5);
      float d = length(uv);
      float shape = smoothstep(0.5, 0.0, d);

      // vertical gradient based on world y
      float t = clamp((vWorldPos.y + uInnerRadius) / (2.0 * uInnerRadius), 0.0, 1.0);
      vec3 col = mix(bottomColor, topColor, t);

      // gentle center brightening and falloff
      float alpha = shape * 0.8 * uOpacity * (0.6 + 0.4 * vScale);

      // additional distance-based fade (soft depth cue)
      float dist = length(vWorldPos - cameraPosition);
      float fade = 1.0 / (1.0 + 0.15 * dist * dist);
      alpha *= fade;

      // slight color modulation for richer tones
      col *= (0.9 + 0.2 * shape);

      // final color: premultiplied alpha for pleasing blending
      gl_FragColor = vec4(col * alpha, alpha);
    }
  `;

  let pointsMaterial, points;
  function buildPoints(){
    if(points){ scene.remove(points); points.geometry.dispose(); points.material.dispose(); }
    const g = createMistPoints(params.particleCount);
    pointsMaterial = new THREE.ShaderMaterial({
      vertexShader: mistVS,
      fragmentShader: mistFS,
      uniforms: {
        uTime: { value: 0 },
        uSpeed: { value: params.speed },
        uSwirl: { value: params.swirl },
        uPointSize: { value: params.basePointSize },
        pixelRatio: { value: renderer.getPixelRatio() },
        topColor: { value: new THREE.Color(params.paletteTop) },
        bottomColor: { value: new THREE.Color(params.paletteBottom) },
        uOpacity: { value: params.mistOpacity },
        uInnerRadius: { value: params.innerRadius },
      },
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: false,
    });
    points = new THREE.Points(g, pointsMaterial);
    // place points at the scene center; the glass mesh is at origin
    scene.add(points);
  }

  buildPoints();

  // ---------- postprocessing (bloom) ----------
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);
  const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), params.bloomStrength, params.bloomRadius, params.bloomThreshold);
  composer.addPass(bloomPass);

  // ---------- GUI ----------
  const gui = new GUI({ width: 320 });
  gui.add(params, 'particleCount', 2000, 120000, 1000).name('Particles').onFinishChange(()=>{ params.particleCount = Math.floor(params.particleCount); buildPoints(); });
  gui.add(params, 'basePointSize', 2, 60, 1).name('Point Size').onChange(v=>{ if(pointsMaterial) pointsMaterial.uniforms.uPointSize.value = v; });
  gui.add(params, 'speed', 0.0, 3.0, 0.01).name('Speed').onChange(v=>{ if(pointsMaterial) pointsMaterial.uniforms.uSpeed.value = v; });
  gui.add(params, 'swirl', 0.0, 2.5, 0.01).name('Swirl');
  gui.add(params, 'mistOpacity', 0.0, 2.0, 0.01).name('Mist Opacity').onChange(v=>{ if(pointsMaterial) pointsMaterial.uniforms.uOpacity.value = v; });
  const bloomFolder = gui.addFolder('Bloom');
  bloomFolder.add(params, 'bloomStrength', 0.0, 2.5, 0.01).name('Strength').onChange(v=>{ bloomPass.strength = v; });
  bloomFolder.add(params, 'bloomRadius', 0.0, 2.5, 0.01).name('Radius').onChange(v=>{ bloomPass.radius = v; });
  bloomFolder.add(params, 'bloomThreshold', 0.0, 1.0, 0.01).name('Threshold').onChange(v=>{ bloomPass.threshold = v; });
  bloomFolder.open();
  const colorFolder = gui.addFolder('Colors');
  colorFolder.addColor(params, 'paletteTop').name('Top Color').onChange(v=>{ envMaterial.uniforms.topColor.value.set(v); if(pointsMaterial) pointsMaterial.uniforms.topColor.value.set(v); });
  colorFolder.addColor(params, 'paletteBottom').name('Bottom Color').onChange(v=>{ envMaterial.uniforms.bottomColor.value.set(v); if(pointsMaterial) pointsMaterial.uniforms.bottomColor.value.set(v); });
  colorFolder.open();

  // ---------- animation loop ----------
  const clock = new THREE.Clock();
  function animate(){
    const t = clock.getElapsedTime();
    if(pointsMaterial) pointsMaterial.uniforms.uTime.value = t;
    if(pointsMaterial) pointsMaterial.uniforms.uSwirl.value = params.swirl;
    controls.update();
    // use composer for bloom
    composer.render();
    requestAnimationFrame(animate);
  }
  animate();

  // ---------- resize handling ----------
  window.addEventListener('resize', onResize);
  function onResize(){
    const w = container.clientWidth; const h = container.clientHeight;
    camera.aspect = w / h; camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
    composer.setSize(w, h);
    if(pointsMaterial) pointsMaterial.uniforms.pixelRatio.value = renderer.getPixelRatio();
  }

  // ---------- small helper: take high-quality screenshot ----------
  // call window.takeScreenshot() from console to download a higher-res PNG
  window.takeScreenshot = async function(scale=2){
    const origPR = renderer.getPixelRatio();
    const w = container.clientWidth; const h = container.clientHeight;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio * scale, 4));
    renderer.setSize(w * scale, h * scale, false);
    composer.setSize(w * scale, h * scale);
    composer.render();
    const data = renderer.domElement.toDataURL('image/png');
    const a = document.createElement('a'); a.href = data; a.download = 'glass-mist.png'; a.click();
    // revert
    renderer.setPixelRatio(origPR);
    renderer.setSize(w, h, false);
    composer.setSize(w, h);
  };

  // ---------- tips for GitHub Pages ----------
  // 1) Save this file as `index.html` in a repo (or docs/index.html).
  // 2) Push to GitHub and enable Pages (branch: main / folder: docs or root).
  // 3) Open in a modern browser (WebGL2 recommended). For mobile, reduce particle count.

  </script>
</body>
</html>

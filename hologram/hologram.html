<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>メタリック鉄球＋ガラス球＋虹色フレア背景（安定版）</title>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
  }
}
</script>
<style>
  html, body { margin:0; height:100%; background:#f0f0f0; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { RoomEnvironment } from "three/addons/environments/RoomEnvironment.js";

// === 基本セットアップ ===
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
camera.position.set(0, 0, 4);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xf0f0f0);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
renderer.outputColorSpace = THREE.SRGBColorSpace;
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// === 物理ベース環境（通信不要の反射環境） ===
const pmrem = new THREE.PMREMGenerator(renderer);
scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;

// === ライト ===
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const key = new THREE.DirectionalLight(0xffffff, 1.2);
key.position.set(3, 4, 5);
scene.add(key);

// === ガラス球 ===
const glassMesh = new THREE.Mesh(
  new THREE.SphereGeometry(1, 64, 64),
  new THREE.MeshPhysicalMaterial({
    transmission: 0.7,
    transparent: true,
    roughness: 0.2,
    metalness: 0.0,
    ior: 1.5,
    thickness: 0.6,
    clearcoat: 1.0,
    clearcoatRoughness: 0.15
  })
);
scene.add(glassMesh);

// === メタリック鉄球 ===
const ironRadius = 0.3;
const ironMesh = new THREE.Mesh(
  new THREE.SphereGeometry(ironRadius, 128, 128),
  new THREE.MeshPhysicalMaterial({
    color: 0xffffff,
    metalness: 1.0,
    roughness: 0.08,
    envMapIntensity: 1.4,
    clearcoat: 1.0,
    clearcoatRoughness: 0.03
  })
);
scene.add(ironMesh);

// === オーラ（Fresnel）— 鉄球の周囲ににじむグロー ===
const auraMaterial = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uColor: { value: new THREE.Color(0x66ccff) },  // お好みで
    uIntensity: { value: 0.8 },
    uPower: { value: 2.2 }
  },
  vertexShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vec4 wp = modelMatrix * vec4(position, 1.0);
      vWorldPos = wp.xyz;
      gl_Position = projectionMatrix * viewMatrix * wp;
    }
  `,
  fragmentShader: `
    varying vec3 vWorldPos;
    varying vec3 vNormal;
    uniform vec3 uColor;
    uniform float uIntensity;
    uniform float uPower;
    void main() {
      vec3 V = normalize(cameraPosition - vWorldPos);
      float fres = pow(1.0 - max(dot(normalize(vNormal), V), 0.0), uPower);
      gl_FragColor = vec4(uColor, fres * uIntensity);
    }
  `
});
const auraMesh = new THREE.Mesh(
  new THREE.SphereGeometry(ironRadius * 1.35, 96, 96),
  auraMaterial
);
scene.add(auraMesh);

// === 虹色フレア（背景リング：シェーダで生成） ===
// 画面全体を覆うサイズの板を奥に配置
const ringPlane = new THREE.Mesh(
  new THREE.PlaneGeometry(10, 10, 1, 1),
  new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uInner: { value: 0.55 },   // 内径（0〜1）
      uOuter: { value: 0.90 },   // 外径（0〜1）
      uFeather: { value: 0.03 }, // フェザー幅
      uAspect: { value: window.innerWidth / window.innerHeight },
      uTime: { value: 0.0 },
      uOpacity: { value: 0.85 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
    fragmentShader: `
      varying vec2 vUv;
      uniform float uInner, uOuter, uFeather, uAspect, uTime, uOpacity;

      // HSL -> RGB
      vec3 hsl2rgb(vec3 c){
        vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
        return c.z + c.y*(rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
      }
      void main() {
        // 中心化＆アスペクト補正
        vec2 p = vUv * 2.0 - 1.0;
        p.x *= uAspect;

        float r = length(p);
        float a = atan(p.y, p.x); // -PI..PI
        float hue = fract(a / (6.2831853) + 0.5 + uTime * 0.02); // ゆっくり回転
        vec3 col = hsl2rgb(vec3(hue, 1.0, 0.5));

        // リングのアルファ（柔らかい内外フチ）
        float innerEdge = smoothstep(uInner, uInner + uFeather, r);
        float outerEdge = 1.0 - smoothstep(uOuter - uFeather, uOuter, r);
        float alpha = innerEdge * outerEdge;

        // 外側にもう一段フェード
        alpha *= (1.0 - smoothstep(uOuter, uOuter + 0.15, r));

        gl_FragColor = vec4(col, alpha * uOpacity);
      }
    `
  })
);
ringPlane.position.z = -0.8;
scene.add(ringPlane);

// === アニメーション ===
const start = performance.now();
function animate(now = performance.now()) {
  requestAnimationFrame(animate);

  const t = (now - start) / 1000;

  // 鉄球のゆっくり回転
  ironMesh.rotation.y = t * 0.3;
  ironMesh.rotation.x = t * 0.15;

  // オーラ球は鉄球に追従
  auraMesh.position.copy(ironMesh.position);

  // 背景リングのわずかな色回転
  ringPlane.material.uniforms.uTime.value = t;

  controls.update();
  renderer.render(scene, camera);
}
animate();

// === リサイズ ===
window.addEventListener("resize", () => {
  const w = window.innerWidth, h = window.innerHeight;
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
  renderer.setSize(w, h);
  ringPlane.material.uniforms.uAspect.value = w / h;
});
</script>
</body>
</html>

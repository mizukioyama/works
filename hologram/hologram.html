<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Glass Sphere — 24h Auto (America)</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.162.0/build/three.module.js",
    "three/": "https://unpkg.com/three@0.162.0/",
    "lil-gui": "https://cdn.jsdelivr.net/npm/lil-gui@0.18/+esm"
  }
}
</script>

<style>
  html,body{height:100%;margin:0;background:#05060a; color:#fff; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;}
  #app{width:100vw;height:100vh;overflow:hidden;position:relative}
  #timeDisplay{
    position:fixed;left:12px;top:12px;z-index:40;
    background:rgba(0,0,0,0.45);padding:8px 10px;border-radius:8px;font-size:14px;
    display:flex;gap:12px;align-items:center;
  }
  #tzSelect{background:transparent;border:1px solid rgba(255,255,255,0.08);color:#fff;padding:4px 6px;border-radius:6px;}
  #note{font-size:12px;color:#ddd;opacity:0.9}
</style>
</head>
<body>
<div id="app">
  <div id="timeDisplay">
    <div id="clock" aria-live="polite">--:--:--</div>
    <select id="tzSelect" aria-label="Timezone">
      <option value="America/New_York">New York (EST/EDT)</option>
      <option value="America/Chicago">Chicago (CST/CDT)</option>
      <option value="America/Denver">Denver (MST/MDT)</option>
      <option value="America/Los_Angeles">Los Angeles (PST/PDT)</option>
    </select>
    <div id="note">24h — 0/24: soft & dull → 12: bright & clear</div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import GUI from "lil-gui";

/* ---------------- scene / renderer ---------------- */
const container = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.setSize(container.clientWidth, container.clientHeight);
container.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x05060a);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 0.05, 100);
camera.position.set(0, 0.8, 3.1);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* --------------- environment (PMREM) ---------------- */
const loader = new THREE.CubeTextureLoader();
const basePath = 'https://threejs.org/examples/textures/cube/SwedishRoyalCastle/';
const urls = [
  basePath + 'px.jpg', basePath + 'nx.jpg',
  basePath + 'py.jpg', basePath + 'ny.jpg',
  basePath + 'pz.jpg', basePath + 'nz.jpg'
];
loader.load(urls, (cube) => {
  const pmrem = new THREE.PMREMGenerator(renderer);
  pmrem.compileEquirectangularShader();
  const envMap = pmrem.fromCubemap(cube).texture;
  scene.environment = envMap;
  // keep background subtle: use cube as background but dim later by exposure
  scene.background = cube;
  pmrem.dispose();
});

/* ---------------- ground / contact shadow ---------------- */
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(20,20),
  new THREE.MeshStandardMaterial({ color: 0x060608, roughness: 0.48, metalness: 0.04 })
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -1.05;
scene.add(ground);

/* ---------------- glass sphere ---------------- */
const sphereGeo = new THREE.SphereGeometry(1.0, 192, 192);
const glassMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  metalness: 0.0,
  roughness: 0.02,
  transmission: 1.0,
  thickness: 0.18,
  ior: 1.52,
  clearcoat: 1.0,
  clearcoatRoughness: 0.02,
  reflectivity: 0.9,
  envMapIntensity: 1.0,
  side: THREE.DoubleSide
});
const glassMesh = new THREE.Mesh(sphereGeo, glassMat);
scene.add(glassMesh);

/* inner thin surface to hint thickness */
const innerMesh = new THREE.Mesh(new THREE.SphereGeometry(0.88, 128, 128), new THREE.MeshPhysicalMaterial({
  color:0xffffff, metalness:0, roughness:0.3, transmission:0.8, thickness:0.02, transparent:true, opacity:0.6
}));
scene.add(innerMesh);

/* subtle suspended particles for depth */
const ptCount = 12000;
const pos = new Float32Array(ptCount*3);
for(let i=0;i<ptCount;i++){
  const r = Math.cbrt(Math.random())*0.9;
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);
  pos[3*i] = r*Math.sin(phi)*Math.cos(theta);
  pos[3*i+1] = r*Math.sin(phi)*Math.sin(theta);
  pos[3*i+2] = r*Math.cos(phi);
}
const pgeo = new THREE.BufferGeometry();
pgeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
const pmat = new THREE.PointsMaterial({ size:0.008, color:0xffffff, transparent:true, opacity:0.12, depthWrite:false });
const particles = new THREE.Points(pgeo, pmat);
scene.add(particles);

/* lights to shape highlights */
const key = new THREE.PointLight(0xfff6e6, 1.0, 20);
key.position.set(4, 4, 3);
scene.add(key);
const fill = new THREE.PointLight(0x7fdcff, 0.6, 20);
fill.position.set(-3, -1.5, 2.8);
scene.add(fill);
scene.add(new THREE.AmbientLight(0xffffff, 0.22));

/* postprocess */
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 0.45, 0.4, 0.85);
composer.addPass(bloom);

/* ---------------- GUI ---------------- */
const gui = new GUI({ width: 300 });
const params = {
  tz: 'America/New_York',
  minTransmission: 0.10,
  maxTransmission: 1.00,
  minRoughness: 0.35,
  maxRoughness: 0.00,
  minThickness: 0.02,
  maxThickness: 0.22,
  minEnv: 0.2,
  maxEnv: 1.2,
  bloom: 0.45,
  manualOverride: false
};
const tzCtrl = gui.add(params, 'tz', {
  "New York (EST/EDT)": "America/New_York",
  "Chicago (CST/CDT)": "America/Chicago",
  "Denver (MST/MDT)": "America/Denver",
  "Los Angeles (PST/PDT)": "America/Los_Angeles"
}).name('Timezone');
gui.add(params, 'manualOverride').name('Manual control');
const gGlass = gui.addFolder('Ranges');
gGlass.add(params, 'minTransmission', 0, 1, 0.01).name('minTransmission'); 
gGlass.add(params, 'maxTransmission', 0, 1, 0.01).name('maxTransmission');
gGlass.add(params, 'minRoughness', 0, 1, 0.01).name('minRoughness');
gGlass.add(params, 'maxRoughness', 0, 1, 0.01).name('maxRoughness');
gGlass.add(params, 'minThickness', 0, 1, 0.001).name('minThickness');
gGlass.add(params, 'maxThickness', 0, 1, 0.001).name('maxThickness');
gGlass.add(params, 'minEnv', 0, 3, 0.01).name('minEnv');
gGlass.add(params, 'maxEnv', 0, 3, 0.01).name('maxEnv');
gGlass.open();
gui.add(bloom, 'strength', 0, 2, 0.01).name('Bloom Strength');

tzCtrl.onChange(v => {
  // reflect selection in top-left select element
  document.getElementById('tzSelect').value = v;
});

/* sync select UI */
const tzSelect = document.getElementById('tzSelect');
tzSelect.value = params.tz;
tzSelect.addEventListener('change', e => {
  params.tz = e.target.value;
  tzCtrl.setValue(params.tz);
});

/* ---------------- time -> material mapping ---------------- */
/*
Mapping function:
  t in [0,24)
  f = 0.5*(1 - cos(pi * t/12))  -> f=0 at t=0/24, f=1 at t=12
Then material parameters are lerped between min/max using f.
We apply easing (smooth transition) so changes are not jerky.
*/
function getLocalTimeInZone(timeZone){
  // returns fractional hours (e.g., 13.5)
  const now = new Date();
  const fmt = new Intl.DateTimeFormat('en-US', { timeZone, hour12: false, hour: '2-digit', minute: '2-digit', second: '2-digit' });
  const parts = fmt.formatToParts(now);
  // Extract h,m,s
  let hh = 0, mm = 0, ss = 0;
  for(const p of parts){
    if(p.type === 'hour') hh = parseInt(p.value,10);
    if(p.type === 'minute') mm = parseInt(p.value,10);
    if(p.type === 'second') ss = parseInt(p.value,10);
  }
  return hh + mm/60 + ss/3600;
}

function timeToPhase(t){
  // t in hours 0..24
  // f = 0 at 0/24, 1 at 12
  return 0.5 * (1 - Math.cos(Math.PI * t / 12));
}

let smoothState = {
  transmission: glassMat.transmission,
  roughness: glassMat.roughness,
  thickness: glassMat.thickness,
  env: glassMat.envMapIntensity,
  bloom: bloom.strength
};

const ease = (current, target, dt, speed=3.5) => current + (target - current) * (1 - Math.exp(-speed * dt));

/* ---------------- clock display ---------------- */
const clockEl = document.getElementById('clock');
function updateClockDisplay(timeZone){
  const now = new Date();
  const fmt = new Intl.DateTimeFormat('en-GB', { timeZone, hour12: false, hour: '2-digit', minute:'2-digit', second:'2-digit' });
  clockEl.textContent = fmt.format(now);
}

/* ---------------- animation loop ---------------- */
const clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // get precise fractional hour in selected timezone
  const hour = getLocalTimeInZone(params.tz);
  updateClockDisplay(params.tz);

  // compute phase
  const phase = timeToPhase(hour); // 0..1

  // compute target values from ranges
  const target = {
    transmission: params.minTransmission + (params.maxTransmission - params.minTransmission) * phase,
    roughness: params.minRoughness + (params.maxRoughness - params.minRoughness) * (1 - phase), // invert: at phase=1 -> maxRoughness (user set), but default set maxRoughness=0 to make smooth
    thickness: params.minThickness + (params.maxThickness - params.minThickness) * phase,
    env: params.minEnv + (params.maxEnv - params.minEnv) * phase,
    bloom: bloom.strength // bloom controlled by GUI directly
  };

  if(!params.manualOverride){
    // smooth towards target
    smoothState.transmission = ease(smoothState.transmission, target.transmission, dt);
    smoothState.roughness = ease(smoothState.roughness, target.roughness, dt);
    smoothState.thickness = ease(smoothState.thickness, target.thickness, dt);
    smoothState.env = ease(smoothState.env, target.env, dt);

    // apply to material & postprocess
    glassMat.transmission = smoothState.transmission;
    glassMat.roughness = smoothState.roughness;
    glassMat.thickness = smoothState.thickness;
    glassMat.envMapIntensity = smoothState.env;
    bloom.strength = params.bloom;
  }

  // subtle breathing + rotation for realism
  const t = performance.now() * 0.00022;
  glassMesh.rotation.y = t * 0.6;
  innerMesh.rotation.y = -t * 0.36;
  particles.rotation.y = t * 0.08;

  controls.update();
  composer.render();

  // update GUI displays if manualOverride toggled off/on
  requestAnimationFrame(()=>{}); // keep loop alive
}

animate();

/* ---------------- resize ---------------- */
window.addEventListener('resize', ()=>{
  const w = container.clientWidth, h = container.clientHeight;
  camera.aspect = w/h; camera.updateProjectionMatrix();
  renderer.setSize(w,h); composer.setSize(w,h);
});

</script>
</body>
</html>

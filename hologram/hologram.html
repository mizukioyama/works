<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>鉄球＋ガラス球＋虹リング</title>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
    }
  }
  </script>
</head>
<body style="margin:0; overflow:hidden;">
<script type="module">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

// === 基本セットアップ ===
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0,0,4);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

// ライティング
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dir = new THREE.DirectionalLight(0xffffff, 1.2);
dir.position.set(3,4,5);
scene.add(dir);

// === ポストプロセス ===
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 1.2, 0.5, 0.0);
composer.addPass(bloom);

// === ガラス球 ===
const glassGeo = new THREE.SphereGeometry(1,64,64);
const glassMat = new THREE.MeshPhysicalMaterial({
  transmission:0.6, transparent:true, opacity:1.0,
  roughness:0.4, metalness:0.0, ior:1.5, thickness:0.5
});
const glass = new THREE.Mesh(glassGeo, glassMat);
scene.add(glass);

// === 鉄球（メタリック） ===
const ironGeo = new THREE.SphereGeometry(0.35,64,64);
const ironMat = new THREE.MeshPhysicalMaterial({
  color:0xffffff, metalness:1.0, roughness:0.1, clearcoat:1.0
});
const iron = new THREE.Mesh(ironGeo, ironMat);
scene.add(iron);

// === 鉄球オーラ（Fresnel風） ===
const haloGeo = new THREE.SphereGeometry(0.42,64,64);
const haloMat = new THREE.ShaderMaterial({
  transparent:true, blending:THREE.AdditiveBlending, depthWrite:false,
  uniforms:{
    uTime:{value:0.0}, uColor:{value:new THREE.Color(1.0,0.8,0.6)}
  },
  vertexShader:`
    varying vec3 vNormal;
    void main(){
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader:`
    varying vec3 vNormal;
    uniform float uTime;
    uniform vec3 uColor;
    void main(){
      float fres = pow(1.0 - abs(dot(vNormal, vec3(0,0,1))), 3.0);
      float pulse = 0.8 + 0.2*sin(uTime*3.0);
      gl_FragColor = vec4(uColor, fres*0.6*pulse);
    }
  `
});
const halo = new THREE.Mesh(haloGeo, haloMat);
scene.add(halo);

// === 背景リング ===
function createRing(r1,r2){
  const geo = new THREE.RingGeometry(r1,r2,256);
  const canvas = document.createElement("canvas");
  canvas.width = canvas.height = 512;
  const ctx = canvas.getContext("2d");
  const grad = ctx.createConicGradient(0,256,256);
  grad.addColorStop(0,"red");
  grad.addColorStop(0.2,"yellow");
  grad.addColorStop(0.4,"lime");
  grad.addColorStop(0.6,"cyan");
  grad.addColorStop(0.8,"blue");
  grad.addColorStop(1.0,"magenta");
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,512,512);
  const tex = new THREE.CanvasTexture(canvas);
  tex.colorSpace = THREE.SRGBColorSpace;
  const mat = new THREE.MeshBasicMaterial({
    map:tex, transparent:true, blending:THREE.AdditiveBlending, side:THREE.DoubleSide
  });
  return new THREE.Mesh(geo, mat);
}
const rings = [];
for(let i=0;i<3;i++){
  const r = createRing(1.5+i*0.2,1.7+i*0.2);
  r.position.z = -0.5;
  scene.add(r);
  rings.push(r);
}

// === アニメーション ===
let start = Date.now();
function animate(){
  requestAnimationFrame(animate);
  const t = (Date.now()-start)/1000;

  // ガラスを60秒で透明化
  glass.material.opacity = Math.max(1.0 - t/60, 0);

  // オーラ
  halo.material.uniforms.uTime.value = t;

  // リング回転
  rings.forEach((r,i)=>{ r.rotation.z += 0.002*(i%2?1:-1); });

  composer.render();
}
animate();

</script>
</body>
</html>
